/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/utils/DebugLogger.ts
var DebugLogger_exports = {};
__export(DebugLogger_exports, {
  DebugLogger: () => DebugLogger
});
var DebugLogger;
var init_DebugLogger = __esm({
  "src/utils/DebugLogger.ts"() {
    DebugLogger = class {
      // Limite pour éviter trop de logs
      /**
       * Active ou désactive le logging.
       */
      static setEnabled(enabled) {
        this.enabled = enabled;
      }
      /**
       * Initialise le conteneur de logs pour un bloc de code donné.
       */
      static init(parentElement) {
        this.logs = [];
        this.logContainer = parentElement.createEl("details", { cls: "chord-grid-debug" });
        const summary = this.logContainer.createEl("summary");
        summary.setText("\u{1F41B} Debug Logs");
        const logContent = this.logContainer.createEl("pre", {
          cls: "chord-grid-debug-content"
        });
        logContent.style.cssText = `
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
      font-family: 'Consolas', 'Monaco', monospace;
    `;
        return this.logContainer;
      }
      /**
       * Enregistre un message de log.
       */
      static log(message, data) {
        if (!this.enabled) return;
        const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString();
        const logMessage = data ? `[${timestamp}] ${message}: ${JSON.stringify(data, null, 2)}` : `[${timestamp}] ${message}`;
        this.logs.push(logMessage);
        if (this.logs.length > this.maxLogs) {
          this.logs.shift();
        }
        console.log(`[ChordGrid] ${message}`, data);
        this.render();
      }
      /**
       * Enregistre un message d'erreur.
       */
      static error(message, error) {
        if (!this.enabled) return;
        const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString();
        const errorMessage = error ? `[${timestamp}] \u274C ERROR: ${message}: ${error.message || JSON.stringify(error)}` : `[${timestamp}] \u274C ERROR: ${message}`;
        this.logs.push(errorMessage);
        console.error(`[ChordGrid] ${message}`, error);
        this.render();
      }
      /**
       * Enregistre un message d'avertissement.
       */
      static warn(message, data) {
        if (!this.enabled) return;
        const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString();
        const warnMessage = data ? `[${timestamp}] \u26A0\uFE0F WARN: ${message}: ${JSON.stringify(data, null, 2)}` : `[${timestamp}] \u26A0\uFE0F WARN: ${message}`;
        this.logs.push(warnMessage);
        console.warn(`[ChordGrid] ${message}`, data);
        this.render();
      }
      /**
       * Met à jour l'affichage des logs.
       */
      static render() {
        if (!this.logContainer) return;
        const logContent = this.logContainer.querySelector(".chord-grid-debug-content");
        if (logContent) {
          logContent.textContent = this.logs.join("\n");
          logContent.scrollTop = logContent.scrollHeight;
        }
      }
      /**
       * Efface tous les logs.
       */
      static clear() {
        this.logs = [];
        this.render();
      }
    };
    __publicField(DebugLogger, "enabled", true);
    __publicField(DebugLogger, "logContainer", null);
    __publicField(DebugLogger, "logs", []);
    __publicField(DebugLogger, "maxLogs", 50);
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ChordGridPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/parser/ChordGridParser.ts
var _ChordGridParser = class _ChordGridParser {
  /**
   * Parse une grille d'accords en notation textuelle.
   * 
   * @param input - Chaîne contenant la grille d'accords en notation textuelle
   * @returns Objet ParseResult contenant :
   *   - grid : la structure ChordGrid parsée
   *   - errors : tableau d'erreurs de validation (mesures mal formées)
   *   - measures : tableau de toutes les mesures
   */
  parse(input) {
    const lines = input.trim().split("\n");
    let stemsDirection = "up";
    let displayRepeatSymbol = false;
    let timeSignatureLine = lines[0];
    if (/stems-down/i.test(timeSignatureLine)) {
      stemsDirection = "down";
      timeSignatureLine = timeSignatureLine.replace(/stems-down\s*/i, "");
    } else if (/stems-up/i.test(timeSignatureLine)) {
      stemsDirection = "up";
      timeSignatureLine = timeSignatureLine.replace(/stems-up\s*/i, "");
    }
    if (/show%/i.test(timeSignatureLine)) {
      displayRepeatSymbol = true;
      timeSignatureLine = timeSignatureLine.replace(/show%\s*/i, "");
    }
    timeSignatureLine = timeSignatureLine.trim();
    if (timeSignatureLine === "" && lines.length > 1) {
      timeSignatureLine = lines[1];
      lines.splice(0, 2, timeSignatureLine);
    } else {
      lines[0] = timeSignatureLine;
    }
    const timeSignature = this.parseTimeSignature(timeSignatureLine);
    timeSignatureLine = timeSignatureLine.replace(/^\s*\d+\/\d+(?:\s+(?:binary|ternary|noauto))?\s*/, "");
    lines[0] = timeSignatureLine;
    const allMeasures = [];
    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
      const line = lines[lineIndex];
      const measures = this.parseLine(line, lineIndex === 0);
      if (measures.length > 0 && lineIndex < lines.length - 1) {
        measures[measures.length - 1].isLineBreak = true;
      }
      allMeasures.push(...measures);
    }
    const renderedLines = this.groupIntoLines(allMeasures, 4);
    const grid = {
      timeSignature,
      measures: allMeasures,
      lines: renderedLines
    };
    const errors = [];
    const expectedQuarterNotes = timeSignature.numerator * (4 / timeSignature.denominator);
    for (let mi = 0; mi < allMeasures.length; mi++) {
      const measure = allMeasures[mi];
      let foundQuarterNotes = 0;
      const countedTuplets = /* @__PURE__ */ new Set();
      for (const beat of measure.beats) {
        for (const n of beat.notes) {
          if (!n.value) continue;
          if (n.tuplet && !countedTuplets.has(n.tuplet.groupId)) {
            countedTuplets.add(n.tuplet.groupId);
            let baseLen = Infinity;
            const tupletNotes = [];
            for (const tupletBeat of measure.beats) {
              for (const tupletNote of tupletBeat.notes) {
                if (tupletNote.tuplet && tupletNote.tuplet.groupId === n.tuplet.groupId) {
                  tupletNotes.push({ value: tupletNote.value, dotted: tupletNote.dotted });
                  if (tupletNote.value > baseLen) {
                    baseLen = tupletNote.value;
                  }
                }
              }
            }
            if (!isFinite(baseLen)) {
              baseLen = 4;
            }
            let cumulativeUnits = 0;
            for (const tupletNote of tupletNotes) {
              const dottedMultiplier = tupletNote.dotted ? 1.5 : 1;
              const unitsOfBaseLen = baseLen / tupletNote.value * dottedMultiplier;
              cumulativeUnits += unitsOfBaseLen;
            }
            let tupletRatio;
            if (n.tuplet.ratio) {
              tupletRatio = n.tuplet.ratio.denominator / n.tuplet.ratio.numerator;
            } else {
              const defaultRatio = _ChordGridParser.DEFAULT_TUPLET_RATIOS[n.tuplet.count];
              if (defaultRatio) {
                tupletRatio = defaultRatio.denominator / defaultRatio.numerator;
              } else {
                const normalCount = Math.pow(2, Math.floor(Math.log2(tupletNotes.length)));
                tupletRatio = normalCount / tupletNotes.length;
              }
            }
            const cumulativeDuration = cumulativeUnits / baseLen;
            const actualDuration = cumulativeDuration * tupletRatio;
            foundQuarterNotes += actualDuration * 4;
          } else if (!n.tuplet) {
            const baseWhole = 1 / n.value;
            const dottedMultiplier = n.dotted ? 1.5 : 1;
            const whole = baseWhole * dottedMultiplier;
            foundQuarterNotes += whole * 4;
          }
        }
      }
      const diff = Math.abs(foundQuarterNotes - expectedQuarterNotes);
      if (diff > 1e-6) {
        errors.push({
          measureIndex: mi,
          measureSource: measure.source,
          expectedQuarterNotes,
          foundQuarterNotes,
          message: `Measure ${mi + 1}: expected ${expectedQuarterNotes} quarter-notes, found ${foundQuarterNotes.toFixed(3)} (diff ${diff.toFixed(3)})`
        });
      }
    }
    return { grid, errors, measures: allMeasures, stemsDirection, displayRepeatSymbol };
  }
  /**
   * Produce simplified syntactic measures for the new analyzer layer (v2.0.0).
   * This ignores any beam grouping and only preserves the raw note sequence per chord segment.
   *
   * Contract:
   * - Returns an array of ParsedMeasure (analyzer-types)
   * - Each measure contains segments with flat notes (ParsedNote)
   * - leadingSpace is propagated from segment parsing
   */
  parseForAnalyzer(input) {
    const result = this.parse(input);
    const measures = result.measures.map((m) => {
      const segments = (m.chordSegments || []).map((seg) => {
        const flatNotes = [];
        seg.beats.forEach((beat, beatIndex) => {
          for (const n of beat.notes) {
            flatNotes.push({
              value: n.value,
              dotted: !!n.dotted,
              isRest: !!n.isRest,
              tieStart: n.tieStart || false,
              tieEnd: n.tieEnd || false,
              tieToVoid: n.tieToVoid || false,
              tieFromVoid: n.tieFromVoid || false,
              beatIndex,
              // Preserve beat index to break beams at beat boundaries
              tuplet: n.tuplet,
              // Preserve tuplet information
              hasLeadingSpace: n.hasLeadingSpace,
              // Preserve spacing flag for tuplet subgroups
              forcedBeamThroughTie: n.forcedBeamThroughTie
              // Preserve [_] syntax
            });
          }
        });
        return {
          chord: seg.chord,
          notes: flatNotes,
          leadingSpace: !!seg.leadingSpace
        };
      });
      return {
        segments,
        timeSignature: result.grid.timeSignature,
        barline: m.barline,
        isLineBreak: m.isLineBreak,
        source: m.source
      };
    });
    return { timeSignature: result.grid.timeSignature, measures };
  }
  parseLine(line, isFirstLine) {
    if (isFirstLine) {
      line = line.replace(/^\d+\/\d+\s*/, "");
    }
    const measures = [];
    const tokens = [];
    const re = /(\|\|:|:?\|\||\|)/g;
    let lastIndex = 0;
    let m;
    const parts = [];
    while ((m = re.exec(line)) !== null) {
      const sep = m[0];
      const text = line.slice(lastIndex, m.index);
      parts.push({ sep: null, text });
      parts.push({ sep, text: "" });
      lastIndex = re.lastIndex;
    }
    const trailing = line.slice(lastIndex);
    if (trailing.length > 0) parts.push({ sep: null, text: trailing });
    let currentText = "";
    for (const p of parts) {
      if (p.sep === null) {
        currentText += p.text || "";
      } else {
        tokens.push({ bar: p.sep, content: currentText });
        currentText = "";
      }
    }
    if (currentText.length > 0 && currentText.trim().length > 0) {
      tokens.push({ bar: "|", content: currentText });
    }
    const measureRe = /^\s*([^\[]+?)?\s*(?:\[([^\]]*)\])?\s*$/;
    const analyzer = new BeamAndTieAnalyzer();
    const segmentRe = /(\s*)([^\[\]\s]+)?\s*\[([^\]]*)\]/g;
    let lastExplicitMeasure = null;
    let pendingStartBarline = null;
    for (let ti = 0; ti < tokens.length; ti++) {
      const t = tokens[ti];
      if (t.content.trim().length === 0 && t.bar === "||:") {
        pendingStartBarline = "||:";
        continue;
      }
      if (t.content.trim().length === 0) {
        continue;
      }
      const text = t.content;
      const bar = t.bar;
      if (text.trim() === "%") {
        if (!lastExplicitMeasure) {
          console.warn("Cannot use '%' repeat notation on first measure");
          continue;
        }
        const clonedMeasure = this.cloneMeasure(lastExplicitMeasure, bar);
        if (pendingStartBarline === "||:") {
          clonedMeasure.isRepeatStart = true;
          pendingStartBarline = null;
        }
        measures.push(clonedMeasure);
        lastExplicitMeasure = clonedMeasure;
        continue;
      }
      const repeatMatch = /^\s*([^\[\]\s]+)\s*\[%\]\s*$/.exec(text);
      if (repeatMatch) {
        if (!lastExplicitMeasure) {
          console.warn("Cannot use '[%]' repeat notation on first measure");
          continue;
        }
        const newChord = repeatMatch[1].trim();
        const clonedMeasure = this.cloneMeasureWithNewChord(lastExplicitMeasure, newChord, bar);
        if (pendingStartBarline === "||:") {
          clonedMeasure.isRepeatStart = true;
          pendingStartBarline = null;
        }
        measures.push(clonedMeasure);
        lastExplicitMeasure = clonedMeasure;
        continue;
      }
      const beats = [];
      let firstChord = "";
      let anySource = "";
      let m2;
      const isFirstMeasureOfLine = tokens.slice(0, ti).every((prev) => prev.content.trim().length === 0);
      const isLastMeasureOfLine = tokens.slice(ti + 1).every((next) => next.content.trim().length === 0);
      const chordSegments = [];
      const FORCED_BEAM_PLACEHOLDER = "";
      const processedText = text.replace(/\[_\]/g, FORCED_BEAM_PLACEHOLDER);
      if (processedText.includes("[")) {
        const allSegments = [];
        let tempMatch;
        const tempRe = new RegExp(segmentRe.source, segmentRe.flags);
        while ((tempMatch = tempRe.exec(processedText)) !== null) {
          const leadingSpaceCapture = tempMatch[1] || "";
          const chord = (tempMatch[2] || "").trim();
          let rhythm = (tempMatch[3] || "").trim();
          rhythm = rhythm.replace(new RegExp(FORCED_BEAM_PLACEHOLDER, "g"), "[_]");
          allSegments.push({ leadingSpace: leadingSpaceCapture, chord, rhythm, source: tempMatch[0] });
        }
        const lastSegmentWithRhythmIndex = allSegments.reduce((lastIdx, seg, idx) => seg.rhythm.length > 0 ? idx : lastIdx, -1);
        let segmentIndex = 0;
        while ((m2 = segmentRe.exec(processedText)) !== null) {
          const leadingSpaceCapture = m2[1] || "";
          const chord = (m2[2] || "").trim();
          let rhythm = (m2[3] || "").trim();
          rhythm = rhythm.replace(new RegExp(FORCED_BEAM_PLACEHOLDER, "g"), "[_]");
          const sourceText = m2[0];
          if (!firstChord && chord) firstChord = chord;
          anySource += (anySource ? " " : "") + sourceText;
          if (rhythm.length > 0) {
            const hasSignificantSpace = (leadingSpaceCapture || "").length > 0;
            const isLastSegment = segmentIndex === lastSegmentWithRhythmIndex;
            const parsedBeats = analyzer.analyzeRhythmGroup(rhythm, chord, isFirstMeasureOfLine, isLastMeasureOfLine, hasSignificantSpace, isLastSegment);
            chordSegments.push({
              chord,
              // utiliser l'accord actuel
              beats: parsedBeats,
              leadingSpace: hasSignificantSpace
            });
            beats.push(...parsedBeats);
          }
          segmentIndex++;
        }
      } else {
        const rhythm = text.trim();
        anySource = text;
        if (rhythm.length > 0) {
          const parsedBeats = analyzer.analyzeRhythmGroup(rhythm, "", isFirstMeasureOfLine, isLastMeasureOfLine, false, true);
          chordSegments.push({
            chord: "",
            beats: parsedBeats,
            leadingSpace: false
          });
          beats.push(...parsedBeats);
        }
      }
      const newMeasure = {
        beats,
        chord: firstChord,
        // garder pour compatibilité
        chordSegments,
        // nouvelle propriété pour tous les accords
        barline: bar,
        isLineBreak: false,
        source: anySource || text
      };
      if (pendingStartBarline === "||:") {
        newMeasure.isRepeatStart = true;
        pendingStartBarline = null;
      } else if (bar === "||:") {
        newMeasure.isRepeatStart = true;
      }
      if (bar === ":||") {
        newMeasure.isRepeatEnd = true;
      }
      measures.push(newMeasure);
      lastExplicitMeasure = newMeasure;
    }
    return measures;
  }
  /**
   * Parse la signature temporelle depuis la première ligne.
   * 
   * @param line - Première ligne contenant la signature temporelle (ex: "4/4 ||: C[4 4 4 4]")
   * @returns Objet TimeSignature avec numérateur et dénominateur
   * @default { numerator: 4, denominator: 4 } si aucune signature n'est trouvée
   */
  /**
   * Parse la signature temporelle et le mode de groupement optionnel.
   * 
   * Syntaxe : "4/4" ou "4/4 binary" ou "6/8 ternary"
   * 
   * @param line - Première ligne contenant la signature temporelle
   * @returns Objet TimeSignature avec numerator, denominator et groupingMode
   */
  parseTimeSignature(line) {
    const m = /^\s*(\d+)\/(\d+)(?:\s+(binary|ternary|noauto))?/.exec(line);
    if (m) {
      const numerator = parseInt(m[1], 10);
      const denominator = parseInt(m[2], 10);
      const groupingMode = m[3] || "auto";
      return {
        numerator,
        denominator,
        beatsPerMeasure: numerator,
        beatUnit: denominator,
        groupingMode
      };
    }
    return {
      numerator: 4,
      denominator: 4,
      beatsPerMeasure: 4,
      beatUnit: 4,
      groupingMode: "auto"
    };
  }
  /**
   * Clone a measure completely (used for '%' notation).
   * Removes tie flags at measure boundaries to prevent cross-measure ties.
   * 
   * @param source - The measure to clone
   * @param barline - The barline type for the new measure
   * @returns A deep clone of the measure with cleared boundary ties
   */
  cloneMeasure(source, barline) {
    const clonedBeats = source.beats.map((beat) => ({
      ...beat,
      notes: beat.notes.map((note) => ({ ...note })),
      beamGroups: beat.beamGroups ? beat.beamGroups.map((bg) => ({ ...bg })) : []
    }));
    const clonedSegments = source.chordSegments.map((segment) => ({
      chord: segment.chord,
      leadingSpace: segment.leadingSpace,
      beats: segment.beats.map((beat) => ({
        ...beat,
        notes: beat.notes.map((note) => ({ ...note })),
        beamGroups: beat.beamGroups ? beat.beamGroups.map((bg) => ({ ...bg })) : []
      }))
    }));
    this.clearMeasureBoundaryTies(clonedBeats, clonedSegments);
    const cloned = {
      beats: clonedBeats,
      chord: source.chord,
      chordSegments: clonedSegments,
      barline,
      isLineBreak: false,
      source: source.source,
      isRepeat: true
    };
    if (barline === "||:") {
      cloned.isRepeatStart = true;
    } else if (barline === ":||") {
      cloned.isRepeatEnd = true;
    }
    return cloned;
  }
  /**
   * Clone a measure with a new chord (used for 'G[%]' notation).
   * Keeps the rhythm but replaces the chord.
   * 
   * @param source - The measure to clone
   * @param newChord - The new chord to apply
   * @param barline - The barline type for the new measure
   * @returns A deep clone of the measure with new chord and cleared boundary ties
   */
  cloneMeasureWithNewChord(source, newChord, barline) {
    const cloned = this.cloneMeasure(source, barline);
    cloned.chord = newChord;
    cloned.chordSegments = cloned.chordSegments.map((segment) => ({
      ...segment,
      chord: newChord
    }));
    cloned.source = `${newChord}[%]`;
    return cloned;
  }
  /**
   * Clear tie flags at the start and end of a measure to prevent
   * ties from crossing measure boundaries in repeated measures.
   * 
   * @param beats - The beats array to modify
   * @param segments - The chord segments array to modify
   */
  clearMeasureBoundaryTies(beats, segments) {
    if (beats.length === 0) return;
    const lastBeat = beats[beats.length - 1];
    if (lastBeat.notes.length > 0) {
      const lastNote = lastBeat.notes[lastBeat.notes.length - 1];
      lastNote.tieStart = false;
      lastNote.tieToVoid = false;
    }
    const firstBeat = beats[0];
    if (firstBeat.notes.length > 0) {
      const firstNote = firstBeat.notes[0];
      firstNote.tieEnd = false;
      firstNote.tieFromVoid = false;
    }
    if (segments.length > 0) {
      const firstSegment = segments[0];
      if (firstSegment.beats.length > 0 && firstSegment.beats[0].notes.length > 0) {
        firstSegment.beats[0].notes[0].tieEnd = false;
        firstSegment.beats[0].notes[0].tieFromVoid = false;
      }
      const lastSegment = segments[segments.length - 1];
      if (lastSegment.beats.length > 0) {
        const lastBeat2 = lastSegment.beats[lastSegment.beats.length - 1];
        if (lastBeat2.notes.length > 0) {
          const lastNote = lastBeat2.notes[lastBeat2.notes.length - 1];
          lastNote.tieStart = false;
          lastNote.tieToVoid = false;
        }
      }
    }
  }
  /**
   * Regroupe les mesures en lignes pour le rendu.
   * 
   * @param measures - Tableau de toutes les mesures
   * @param perLine - Nombre de mesures par ligne (généralement 4)
   * @returns Tableau de lignes, chaque ligne contenant un tableau de mesures
   */
  groupIntoLines(measures, perLine) {
    const lines = [];
    for (let i = 0; i < measures.length; i += perLine) {
      lines.push(measures.slice(i, i + perLine));
    }
    return lines;
  }
};
/**
 * Table des ratios par défaut pour les tuplets courants.
 * 
 * Convention musicale (compatible MuseScore) :
 * N:M signifie "N unités de baseLen dans le temps de M unités de même valeur"
 * 
 * baseLen = la plus petite valeur rythmique du tuplet (unité de référence)
 * 
 * Exemples :
 * - {8 8 8}3:2 → 3 croches dans le temps de 2 croches (baseLen = 1/8)
 * - {816-16 1616 8 8}5:4 → contenu équivalent à 5 croches dans le temps de 4 croches (baseLen = 1/16)
 * - {16 16 16}3:2 → 3 doubles-croches dans le temps de 2 doubles-croches (baseLen = 1/16)
 * 
 * Le ratio appliqué est : durée_réelle = durée_cumulative × (M/N)
 * où durée_cumulative est exprimée en unités de baseLen
 * 
 * Cette table peut être étendue selon les besoins musicaux.
 * Pour imposer un ratio spécifique, utiliser la syntaxe {...}N:M
 */
__publicField(_ChordGridParser, "DEFAULT_TUPLET_RATIOS", {
  // Tuplets en temps simple (les plus courants)
  3: { numerator: 3, denominator: 2 },
  // Triplet : 3 notes dans le temps de 2
  5: { numerator: 5, denominator: 4 },
  // Quintuplet : 5 notes dans le temps de 4
  6: { numerator: 6, denominator: 4 },
  // Sextuplet : 6 notes dans le temps de 4
  7: { numerator: 7, denominator: 4 },
  // Septuplet : 7 notes dans le temps de 4
  9: { numerator: 9, denominator: 8 },
  // Nonuplet : 9 notes dans le temps de 8
  10: { numerator: 10, denominator: 8 },
  // Décuplet : 10 notes dans le temps de 8
  11: { numerator: 11, denominator: 8 },
  // 11-uplet : 11 notes dans le temps de 8
  12: { numerator: 12, denominator: 8 },
  // 12-uplet : 12 notes dans le temps de 8
  13: { numerator: 13, denominator: 8 },
  // 13-uplet : 13 notes dans le temps de 8
  15: { numerator: 15, denominator: 8 },
  // 15-uplet : 15 notes dans le temps de 8
  // Tuplets en temps composé (moins courants, mais nécessaires)
  2: { numerator: 2, denominator: 3 },
  // Duplet : 2 notes dans le temps de 3
  4: { numerator: 4, denominator: 3 },
  // Quadruplet : 4 notes dans le temps de 3
  8: { numerator: 8, denominator: 6 }
  // Octuplet : 8 notes dans le temps de 6
});
var ChordGridParser = _ChordGridParser;
var BeamAndTieAnalyzer = class {
  constructor() {
    __publicField(this, "tieContext");
    // Garder le contexte du dernier groupe de notes pour détecter
    // si deux segments doivent être liés ou séparés
    __publicField(this, "rhythmContext");
    this.tieContext = {
      lastNote: null,
      crossMeasure: false,
      crossLine: false,
      pendingTieToVoid: false
    };
    this.rhythmContext = {
      lastGroupTime: 0,
      lastGroupHasSpace: false,
      lastBeamableNotes: []
    };
  }
  analyzeRhythmGroup(rhythmStr, chord, isFirstMeasureOfLine, isLastMeasureOfLine, hasSignificantSpace = false, isLastSegment = true) {
    var _a, _b, _c, _d, _e, _f, _g;
    const beats = [];
    let currentBeat = [];
    let lastBeatLastNoteRef = null;
    let i = 0;
    let pendingTieFromVoid = false;
    while (i < rhythmStr.length) {
      if (rhythmStr[i] === "{") {
        const closeIdx = rhythmStr.indexOf("}", i);
        if (closeIdx > i) {
          let numStr = "";
          let j = closeIdx + 1;
          while (j < rhythmStr.length && /\d/.test(rhythmStr[j])) {
            numStr += rhythmStr[j];
            j++;
          }
          let explicitRatio;
          if (j < rhythmStr.length && rhythmStr[j] === ":") {
            j++;
            let ratioStr = "";
            while (j < rhythmStr.length && /\d/.test(rhythmStr[j])) {
              ratioStr += rhythmStr[j];
              j++;
            }
            const denominatorValue = parseInt(ratioStr, 10);
            if (denominatorValue > 0 && numStr) {
              explicitRatio = {
                numerator: parseInt(numStr, 10),
                denominator: denominatorValue
              };
            }
          }
          const tupletCount = parseInt(numStr, 10);
          if (tupletCount > 0) {
            const inner = rhythmStr.slice(i + 1, closeIdx);
            const subGroups = inner.split(" ");
            let tupletNoteIndex = 0;
            for (let g = 0; g < subGroups.length; g++) {
              const group = subGroups[g];
              let k = 0;
              let isFirstNoteOfThisSubGroup = true;
              let pendingTieFromPrevious = false;
              while (k < group.length) {
                if (group[k] === "_") {
                  if (k === 0) {
                    pendingTieFromPrevious = true;
                  } else {
                    if (currentBeat.length > 0) {
                      this.markTieStart(currentBeat);
                    }
                  }
                  k++;
                  continue;
                }
                let note2;
                if (group[k] === "-") {
                  note2 = this.parseNote(group, k + 1);
                  note2.isRest = true;
                  k += ((_a = note2.length) != null ? _a : 0) + 1;
                } else {
                  note2 = this.parseNote(group, k);
                  k += (_b = note2.length) != null ? _b : 0;
                }
                if (pendingTieFromPrevious) {
                  note2.tieEnd = true;
                  pendingTieFromPrevious = false;
                }
                if ((_c = this.tieContext.lastNote) == null ? void 0 : _c.tieStart) {
                  note2.tieEnd = true;
                  this.tieContext.lastNote = null;
                }
                note2.tuplet = {
                  count: tupletCount,
                  groupId: `T${i}_${closeIdx}`,
                  position: tupletNoteIndex === 0 ? "start" : tupletNoteIndex === tupletCount - 1 ? "end" : "middle",
                  ...explicitRatio && { ratio: explicitRatio }
                };
                if (g > 0 && isFirstNoteOfThisSubGroup) {
                  note2.hasLeadingSpace = true;
                  isFirstNoteOfThisSubGroup = false;
                }
                currentBeat.push(note2);
                tupletNoteIndex++;
              }
            }
            i = j;
            continue;
          }
        }
      }
      if (rhythmStr[i] === "[" && i + 2 < rhythmStr.length && rhythmStr[i + 1] === "_" && rhythmStr[i + 2] === "]") {
        if (currentBeat.length > 0) {
          const lastNote = currentBeat[currentBeat.length - 1];
          lastNote.forcedBeamThroughTie = true;
          lastNote.tieStart = true;
          this.tieContext.lastNote = lastNote;
        }
        i += 3;
        continue;
      }
      if (rhythmStr[i] === "_") {
        if (i === rhythmStr.length - 1) {
          if (isLastSegment && isLastMeasureOfLine) {
            this.markTieToVoid(currentBeat);
          } else {
            this.markTieStart(currentBeat);
          }
        } else if (i === 0 && isFirstMeasureOfLine) {
          if ((_d = this.tieContext.lastNote) == null ? void 0 : _d.tieStart) {
          } else {
            pendingTieFromVoid = true;
            this.tieContext.pendingTieToVoid = false;
          }
        } else if (currentBeat.length === 0 && lastBeatLastNoteRef) {
          lastBeatLastNoteRef.tieStart = true;
          this.tieContext.lastNote = lastBeatLastNoteRef;
        } else {
          this.markTieStart(currentBeat);
        }
        i++;
        continue;
      }
      if (rhythmStr[i] === " ") {
        if (currentBeat.length > 0) {
          const lastIdx = currentBeat.length - 1;
          beats.push(this.createBeat(currentBeat));
          lastBeatLastNoteRef = beats[beats.length - 1].notes[lastIdx] || null;
          currentBeat = [];
        }
        i++;
        continue;
      }
      if (rhythmStr[i] === "-") {
        i++;
        const note2 = this.parseNote(rhythmStr, i);
        note2.isRest = true;
        currentBeat.push(note2);
        i += (_e = note2.length) != null ? _e : 0;
        continue;
      }
      const note = this.parseNote(rhythmStr, i);
      if (pendingTieFromVoid) {
        note.tieFromVoid = true;
        pendingTieFromVoid = false;
      }
      if ((_f = this.tieContext.lastNote) == null ? void 0 : _f.tieStart) {
        note.tieEnd = true;
        this.tieContext.lastNote = null;
      }
      currentBeat.push(note);
      i += (_g = note.length) != null ? _g : 0;
    }
    if (currentBeat.length > 0) {
      beats.push(this.createBeat(currentBeat));
    }
    this.rhythmContext.lastGroupHasSpace = hasSignificantSpace;
    return beats;
  }
  markTieToVoid(notes) {
    if (notes.length > 0) {
      const lastNote = notes[notes.length - 1];
      lastNote.tieStart = true;
      lastNote.tieToVoid = true;
      this.tieContext.pendingTieToVoid = true;
    }
  }
  parseNote(rhythmStr, startIndex) {
    let isRest = false;
    let offset = startIndex;
    if (rhythmStr[startIndex] === "-") {
      isRest = true;
      offset += 1;
    }
    const VALID = ["64", "32", "16", "8", "4", "2", "1"];
    for (const v of VALID) {
      if (rhythmStr.startsWith(v, offset)) {
        let len = v.length;
        let dotted = false;
        if (offset + len < rhythmStr.length && rhythmStr[offset + len] === ".") {
          dotted = true;
          len += 1;
        }
        const totalLen = offset - startIndex + len;
        return {
          value: parseInt(v),
          dotted,
          tieStart: false,
          tieEnd: false,
          tieToVoid: false,
          tieFromVoid: false,
          isRest,
          position: startIndex,
          length: totalLen
        };
      }
    }
    return {
      value: 4,
      dotted: false,
      tieStart: false,
      tieEnd: false,
      tieToVoid: false,
      tieFromVoid: false,
      isRest: false,
      position: startIndex,
      length: 1
    };
  }
  markTieStart(notes) {
    if (notes.length === 0) return;
    const last = notes[notes.length - 1];
    last.tieStart = true;
    this.tieContext.lastNote = last;
    this.tieContext.crossMeasure = true;
  }
  createBeat(notes) {
    const beatNotes = notes.map((n) => ({ ...n }));
    const beamGroups = [];
    let hasBeam = false;
    const beamableNotes = beatNotes.filter((n) => n.value >= 8 && !n.isRest);
    if (beamableNotes.length > 0) {
      const hasIncomingTie = beamableNotes[0].tieEnd || beamableNotes[0].tieFromVoid;
      const prevBeamableCount = this.rhythmContext.lastBeamableNotes.length;
      if (!this.rhythmContext.lastGroupHasSpace && (hasIncomingTie || prevBeamableCount > 0)) {
        beamGroups.push({
          startIndex: 0,
          endIndex: beamableNotes.length - 1,
          noteCount: prevBeamableCount + beamableNotes.length
        });
        hasBeam = true;
      } else {
        beamGroups.push({
          startIndex: 0,
          endIndex: beamableNotes.length - 1,
          noteCount: beamableNotes.length
        });
        hasBeam = beamableNotes.length > 1;
      }
    }
    this.rhythmContext.lastBeamableNotes = beamableNotes;
    return {
      notes: beatNotes,
      hasBeam,
      beamGroups
    };
  }
  // ...existing code...
};

// src/renderer/constants.ts
var SVG_NS = "http://www.w3.org/2000/svg";

// src/renderer/RestRenderer.ts
var RestRenderer = class {
  // Hauteur de référence d'une quarter note (slash + stem)
  constructor(collisionManager) {
    this.collisionManager = collisionManager;
    // Rendering style constants
    __publicField(this, "dotRadius", 1.8);
    __publicField(this, "NOTE_HEIGHT", 30);
  }
  /**
   * Dessine un silence selon sa valeur rythmique.
   * 
   * @param svg - Élément SVG parent
   * @param note - Note marquée comme silence (isRest=true)
   * @param x - Position X du silence
   * @param y - Position Y de référence (ligne de portée)
   */
  drawRest(svg, note, x, y) {
    if (note.value === 1) {
      this.drawWholeRest(svg, x, y, note.dotted);
      this.registerRestBBox(x, y, 10, 4, note);
    } else if (note.value === 2) {
      this.drawHalfRest(svg, x, y, note.dotted);
      this.registerRestBBox(x, y - 4, 10, 4, note);
    } else if (note.value === 4) {
      this.drawQuarterRest(svg, x, y, note.dotted);
      this.registerRestBBox(x, y - 24, 8, 24, note);
    } else if (note.value === 8) {
      this.drawEighthRest(svg, x, y, note.dotted);
      this.registerRestBBox(x, y - 18, 8, 18, note);
    } else if (note.value === 16) {
      this.drawSixteenthRest(svg, x, y, note.dotted);
      this.registerRestBBox(x, y - 24, 10, 24, note);
    } else if (note.value === 32) {
      this.drawThirtySecondRest(svg, x, y, note.dotted);
      this.registerRestBBox(x, y - 28, 10, 28, note);
    } else if (note.value === 64) {
      this.drawSixtyFourthRest(svg, x, y, note.dotted);
      this.registerRestBBox(x, y - 32, 12, 32, note);
    }
  }
  registerRestBBox(x, y, width, height, note) {
    if (!this.collisionManager) return;
    const bbox = { x: x - width / 2, y, width, height };
    this.collisionManager.registerElement("rest", bbox, 6, { value: note.value, dotted: note.dotted });
  }
  drawWholeRest(svg, x, y, dotted) {
    const width = 10;
    const height = 4;
    const rect = document.createElementNS(SVG_NS, "rect");
    rect.setAttribute("x", String(x - width / 2));
    rect.setAttribute("y", String(y));
    rect.setAttribute("width", String(width));
    rect.setAttribute("height", String(height));
    rect.setAttribute("fill", "black");
    svg.appendChild(rect);
    if (dotted) {
      this.drawDot(svg, x + width + 2, y);
    }
  }
  drawHalfRest(svg, x, y, dotted) {
    const width = 10;
    const height = 4;
    const rect = document.createElementNS(SVG_NS, "rect");
    rect.setAttribute("x", String(x - width / 2));
    rect.setAttribute("y", String(y - height));
    rect.setAttribute("width", String(width));
    rect.setAttribute("height", String(height));
    rect.setAttribute("fill", "black");
    svg.appendChild(rect);
    if (dotted) {
      this.drawDot(svg, x + width + 2, y - 2);
    }
  }
  drawQuarterRest(svg, x, y, dotted) {
    const TARGET_HEIGHT = 24;
    const SYMBOL_HEIGHT = 12;
    const SCALE = TARGET_HEIGHT / SYMBOL_HEIGHT;
    const SYMBOL_CENTER_X = 512;
    const SYMBOL_CENTER_Y = 75;
    const group = document.createElementNS(SVG_NS, "g");
    group.setAttribute("transform", `translate(${x},${y}) scale(${SCALE}) translate(${-SYMBOL_CENTER_X},${-SYMBOL_CENTER_Y})`);
    const path = document.createElementNS(SVG_NS, "path");
    path.setAttribute("d", "m 512.254,71.019 c -0.137,0.058 -0.219,0.258 -0.156,0.398 0.019,0.02 0.218,0.258 0.418,0.52 0.457,0.515 0.535,0.637 0.636,0.875 0.399,0.816 0.18,1.855 -0.519,2.512 -0.059,0.078 -0.317,0.296 -0.559,0.476 -0.695,0.598 -1.015,0.938 -1.133,1.238 -0.043,0.079 -0.043,0.157 -0.043,0.278 -0.019,0.277 0,0.301 0.821,1.254 1.113,1.336 1.91,2.273 1.972,2.332 l 0.059,0.058 -0.078,-0.039 c -1.098,-0.457 -2.332,-0.676 -2.75,-0.476 -0.141,0.058 -0.223,0.14 -0.281,0.277 -0.161,0.34 -0.118,0.84 0.121,1.574 0.218,0.66 0.656,1.535 1.093,2.192 0.18,0.281 0.52,0.718 0.559,0.738 0.059,0.059 0.141,0.039 0.199,0 0.059,-0.078 0.059,-0.141 -0.058,-0.277 -0.418,-0.598 -0.617,-1.836 -0.379,-2.493 0.097,-0.296 0.219,-0.457 0.437,-0.558 0.578,-0.258 1.856,0.062 2.391,0.597 0.039,0.04 0.121,0.122 0.16,0.141 0.141,0.059 0.34,-0.019 0.399,-0.16 0.082,-0.141 0.039,-0.238 -0.141,-0.457 -0.336,-0.399 -1.352,-1.594 -1.492,-1.774 -0.36,-0.418 -0.52,-0.816 -0.559,-1.316 -0.019,-0.637 0.238,-1.312 0.719,-1.754 0.058,-0.078 0.316,-0.297 0.555,-0.476 0.738,-0.618 1.039,-0.957 1.156,-1.278 0.082,-0.258 0.043,-0.496 -0.137,-0.715 -0.062,-0.058 -0.758,-0.918 -1.574,-1.894 -1.117,-1.313 -1.516,-1.793 -1.574,-1.813 -0.082,-0.019 -0.18,-0.019 -0.262,0.02 z");
    path.setAttribute("fill", "#000000");
    group.appendChild(path);
    svg.appendChild(group);
    if (dotted) this.drawDot(svg, x + 12, y - 4);
  }
  drawEighthRest(svg, x, y, dotted) {
    const TARGET_HEIGHT = 18;
    const SYMBOL_HEIGHT = 9;
    const SCALE = TARGET_HEIGHT / SYMBOL_HEIGHT;
    const SYMBOL_CENTER_X = 531;
    const SYMBOL_CENTER_Y = 78;
    const group = document.createElementNS(SVG_NS, "g");
    group.setAttribute("transform", `translate(${x},${y}) scale(${SCALE}) translate(${-SYMBOL_CENTER_X},${-SYMBOL_CENTER_Y})`);
    const path = document.createElementNS(SVG_NS, "path");
    path.setAttribute("d", "m 531.098,74.847 c -0.52,0.098 -0.918,0.457 -1.098,0.953 -0.039,0.16 -0.039,0.199 -0.039,0.418 0,0.301 0.019,0.461 0.16,0.699 0.199,0.399 0.617,0.719 1.094,0.836 0.5,0.141 1.336,0.02 2.293,-0.297 l 0.238,-0.082 -1.176,3.25 -1.156,3.246 c 0,0 0.039,0.02 0.102,0.063 0.117,0.078 0.316,0.137 0.457,0.137 0.238,0 0.539,-0.137 0.578,-0.258 0,-0.039 0.558,-1.934 1.234,-4.184 l 1.195,-4.125 -0.039,-0.058 c -0.097,-0.121 -0.296,-0.16 -0.418,-0.063 -0.039,0.039 -0.101,0.121 -0.14,0.18 -0.18,0.301 -0.637,0.836 -0.875,1.035 -0.219,0.18 -0.34,0.199 -0.539,0.121 -0.18,-0.098 -0.239,-0.199 -0.36,-0.738 -0.117,-0.535 -0.257,-0.778 -0.558,-0.977 -0.278,-0.179 -0.637,-0.238 -0.953,-0.156 z");
    path.setAttribute("fill", "#000000");
    group.appendChild(path);
    svg.appendChild(group);
    if (dotted) this.drawDot(svg, x + 10, y - 2);
  }
  drawSixteenthRest(svg, x, y, dotted) {
    const TARGET_HEIGHT = 24;
    const SYMBOL_HEIGHT = 14.5;
    const SCALE = TARGET_HEIGHT / SYMBOL_HEIGHT;
    const SYMBOL_CENTER_X = 544;
    const SYMBOL_CENTER_Y = 81;
    const group = document.createElementNS(SVG_NS, "g");
    group.setAttribute("transform", `translate(${x},${y}) scale(${SCALE}) translate(${-SYMBOL_CENTER_X},${-SYMBOL_CENTER_Y})`);
    const path = document.createElementNS(SVG_NS, "path");
    path.setAttribute("d", "m 544.191,74.847 c -0.519,0.098 -0.918,0.457 -1.093,0.953 -0.043,0.16 -0.043,0.199 -0.043,0.418 0,0.301 0.019,0.461 0.16,0.699 0.199,0.399 0.617,0.719 1.098,0.836 0.496,0.141 1.292,0.039 2.25,-0.277 0.14,-0.059 0.257,-0.102 0.257,-0.082 0,0.023 -0.894,2.93 -0.933,3.031 -0.102,0.258 -0.442,0.735 -0.739,1.035 -0.277,0.278 -0.418,0.34 -0.636,0.239 -0.18,-0.098 -0.239,-0.2 -0.36,-0.739 -0.101,-0.398 -0.179,-0.617 -0.339,-0.773 -0.418,-0.461 -1.137,-0.52 -1.692,-0.16 -0.262,0.179 -0.461,0.457 -0.578,0.758 -0.043,0.156 -0.043,0.199 -0.043,0.417 0,0.297 0.023,0.458 0.16,0.696 0.199,0.398 0.617,0.719 1.098,0.836 0.219,0.062 0.777,0.062 1.156,0 0.316,-0.059 0.695,-0.157 1.074,-0.278 0.16,-0.058 0.301,-0.097 0.301,-0.078 0,0 -1.953,6.356 -1.992,6.453 0,0.02 0.156,0.141 0.316,0.18 0.16,0.063 0.321,0.063 0.481,0 0.156,-0.039 0.316,-0.137 0.316,-0.199 0.02,-0.02 0.817,-3.027 1.793,-6.676 l 1.774,-6.633 -0.039,-0.058 c -0.079,-0.121 -0.239,-0.141 -0.379,-0.082 -0.079,0.039 -0.079,0.039 -0.317,0.398 -0.199,0.32 -0.48,0.656 -0.64,0.816 -0.219,0.18 -0.336,0.219 -0.536,0.141 -0.179,-0.098 -0.242,-0.199 -0.359,-0.738 -0.121,-0.535 -0.262,-0.778 -0.559,-0.977 -0.277,-0.179 -0.636,-0.238 -0.957,-0.156 z");
    path.setAttribute("fill", "#000000");
    group.appendChild(path);
    svg.appendChild(group);
    if (dotted) this.drawDot(svg, x + 10, y - 2);
  }
  drawThirtySecondRest(svg, x, y, dotted) {
    const TARGET_HEIGHT = 28;
    const SYMBOL_HEIGHT = 21;
    const SCALE = TARGET_HEIGHT / SYMBOL_HEIGHT;
    const SYMBOL_CENTER_X = 554;
    const SYMBOL_CENTER_Y = 76;
    const group = document.createElementNS(SVG_NS, "g");
    group.setAttribute("transform", `translate(${x},${y}) scale(${SCALE}) translate(${-SYMBOL_CENTER_X},${-SYMBOL_CENTER_Y})`);
    const path = document.createElementNS(SVG_NS, "path");
    path.setAttribute("d", "m 553.789,69.863 c -0.516,0.101 -0.918,0.461 -1.094,0.957 -0.043,0.16 -0.043,0.199 -0.043,0.418 0,0.218 0,0.3 0.043,0.418 0.137,0.441 0.418,0.777 0.856,0.976 0.297,0.16 0.437,0.18 0.855,0.18 0.52,0 0.957,-0.078 1.657,-0.297 0.179,-0.063 0.316,-0.102 0.316,-0.102 0.019,0 -0.16,0.7 -0.399,1.536 -0.296,1.175 -0.417,1.554 -0.457,1.671 -0.16,0.301 -0.5,0.758 -0.718,0.957 -0.2,0.18 -0.317,0.219 -0.516,0.141 -0.18,-0.098 -0.242,-0.199 -0.359,-0.738 -0.102,-0.399 -0.18,-0.617 -0.34,-0.778 -0.418,-0.457 -1.137,-0.515 -1.692,-0.156 -0.261,0.176 -0.46,0.457 -0.578,0.754 -0.043,0.16 -0.043,0.199 -0.043,0.418 0,0.301 0.024,0.461 0.161,0.699 0.199,0.399 0.617,0.719 1.097,0.836 0.219,0.063 0.778,0.063 1.156,0 0.317,-0.058 0.696,-0.16 1.075,-0.277 0.179,-0.059 0.32,-0.102 0.32,-0.102 0,0.02 -0.797,3.051 -0.84,3.11 -0.156,0.34 -0.476,0.758 -0.715,0.996 -0.258,0.258 -0.398,0.301 -0.617,0.219 -0.18,-0.098 -0.242,-0.2 -0.359,-0.739 -0.102,-0.398 -0.18,-0.617 -0.34,-0.773 -0.418,-0.461 -1.137,-0.52 -1.692,-0.16 -0.261,0.179 -0.46,0.457 -0.578,0.758 -0.043,0.156 -0.043,0.199 -0.043,0.417 0,0.219 0,0.297 0.043,0.418 0.137,0.438 0.418,0.778 0.856,0.977 0.32,0.16 0.437,0.18 0.875,0.18 0.32,0 0.422,0 0.679,-0.043 0.36,-0.059 0.739,-0.176 1.157,-0.297 l 0.258,-0.102 v 0.063 c -0.02,0.078 -1.696,6.375 -1.715,6.414 -0.02,0.082 0.34,0.238 0.558,0.238 0.219,0 0.539,-0.137 0.559,-0.238 0.019,-0.02 0.976,-4.145 2.172,-9.164 2.133,-9.086 2.133,-9.106 2.094,-9.168 -0.063,-0.078 -0.161,-0.117 -0.282,-0.117 -0.14,0.019 -0.199,0.078 -0.34,0.316 -0.277,0.481 -0.597,0.898 -0.773,1.039 -0.121,0.078 -0.223,0.078 -0.379,0.02 -0.18,-0.102 -0.242,-0.2 -0.359,-0.739 -0.121,-0.539 -0.262,-0.777 -0.559,-0.976 -0.277,-0.18 -0.637,-0.238 -0.957,-0.16 z");
    path.setAttribute("fill", "#000000");
    group.appendChild(path);
    svg.appendChild(group);
    if (dotted) this.drawDot(svg, x + 10, y - 2);
  }
  drawSixtyFourthRest(svg, x, y, dotted) {
    const TARGET_HEIGHT = 32;
    const SYMBOL_HEIGHT = 52;
    const SCALE = TARGET_HEIGHT / SYMBOL_HEIGHT;
    const SYMBOL_CENTER_X = 608;
    const SYMBOL_CENTER_Y = 45;
    const group = document.createElementNS(SVG_NS, "g");
    group.setAttribute("transform", `translate(${x},${y}) scale(${SCALE}) translate(${-SYMBOL_CENTER_X},${-SYMBOL_CENTER_Y})`);
    const path = document.createElementNS(SVG_NS, "path");
    path.setAttribute("d", "m 608.27627,17.897034 c -0.9342,0.1818 -1.6524,0.8298 -1.9692,1.7226 -0.0774,0.288 -0.0774,0.3582 -0.0774,0.7524 0,0.3924 0,0.54 0.0774,0.7524 0.2466,0.7938 0.7524,1.3986 1.5408,1.7568 0.5688,0.288 0.7866,0.324 1.575,0.324 0.5418,0 0.7524,0 1.188,-0.0702 0.5688,-0.1062 1.3572,-0.324 1.9692,-0.5346 l 0.3942,-0.1476 -0.036,0.1476 c -0.0342,0.0702 -0.288,1.3212 -0.612,2.7558 -0.5688,2.511 -0.6048,2.6586 -0.7866,2.9808 -0.3942,0.8226 -0.963,1.611 -1.3644,1.8648 -0.2106,0.1404 -0.3942,0.1404 -0.6408,0.0342 -0.3222,-0.1764 -0.4356,-0.3582 -0.6462,-1.3284 -0.1836,-0.7182 -0.324,-1.1106 -0.612,-1.4004 -0.7524,-0.8226 -2.0466,-0.927 -3.051,-0.2808 -0.4644,0.3168 -0.8226,0.8226 -1.0332,1.3572 -0.0774,0.288 -0.0774,0.3582 -0.0774,0.7524 0,0.5418 0.0342,0.8298 0.288,1.2582 0.3582,0.7182 1.1106,1.2942 1.9764,1.5048 0.3924,0.1134 1.3986,0.1134 2.0808,0 0.5688,-0.1044 1.251,-0.288 1.9332,-0.4986 0.324,-0.1062 0.5418,-0.1836 0.576,-0.1836 0,0.036 -1.2222,5.4216 -1.2924,5.598 -0.2196,0.4644 -0.7884,1.3644 -1.2168,1.827 -0.4716,0.4302 -0.6822,0.5076 -1.0764,0.36 -0.324,-0.1764 -0.4356,-0.36 -0.6462,-1.3302 -0.1836,-0.7164 -0.324,-1.1106 -0.612,-1.3914 -0.7524,-0.8298 -2.0466,-0.936 -3.051,-0.288 -0.4644,0.3222 -0.8226,0.8226 -1.0422,1.3644 -0.0702,0.2808 -0.0702,0.3582 -0.0702,0.7506 0,0.5346 0.036,0.8244 0.2898,1.2528 0.3582,0.7164 1.1106,1.2942 1.9746,1.5048 0.9288,0.252 2.475,0.0414 4.2336,-0.5346 0.2448,-0.1062 0.4986,-0.1836 0.4986,-0.1836 0,0.0432 -0.288,1.224 -0.612,2.6928 -0.5346,2.511 -0.5688,2.6928 -0.7524,3.0096 -0.288,0.612 -0.927,1.4778 -1.3644,1.8702 -0.3582,0.324 -0.603,0.3942 -0.963,0.2466 -0.3222,-0.1764 -0.4356,-0.3582 -0.6462,-1.3212 -0.1836,-0.7182 -0.324,-1.1124 -0.612,-1.4004 -0.7524,-0.8298 -2.0466,-0.9342 -3.051,-0.288 -0.4644,0.324 -0.8226,0.8226 -1.0332,1.3644 -0.0774,0.288 -0.0774,0.3582 -0.0774,0.7524 0,0.5346 0.0342,0.8226 0.288,1.251 0.3582,0.7182 1.1106,1.2942 1.9746,1.512 0.9288,0.2466 2.7216,0 4.4802,-0.612 0.2178,-0.0702 0.3582,-0.1044 0.3582,-0.1044 0,0.0342 -2.511,11.2914 -2.6154,11.6496 0,0.0774 0.0342,0.1134 0.1746,0.1836 0.2196,0.1404 0.5778,0.2538 0.8298,0.2538 0.2466,0 0.6048,-0.1134 0.8226,-0.2538 0.1476,-0.0702 0.1836,-0.1062 0.2196,-0.288 0,-0.1062 1.8972,-9.5418 4.2318,-20.9826 3.6918,-18.4356 4.1562,-20.7972 4.1202,-20.8746 -0.1044,-0.1764 -0.2466,-0.2466 -0.4644,-0.2466 -0.3222,0 -0.3924,0.0702 -0.7164,0.6822 -0.4644,0.8928 -0.936,1.539 -1.2582,1.7928 -0.1764,0.1404 -0.36,0.1404 -0.6408,0.036 -0.3222,-0.1836 -0.4356,-0.36 -0.6462,-1.3302 -0.2178,-0.9702 -0.4716,-1.3986 -1.0062,-1.7568 -0.5058,-0.324 -1.1448,-0.4284 -1.7226,-0.288 z");
    path.setAttribute("fill", "#000000");
    group.appendChild(path);
    svg.appendChild(group);
    if (dotted) this.drawDot(svg, x + 10, y - 2);
  }
  drawDot(svg, x, y) {
    const circle = document.createElementNS(SVG_NS, "circle");
    circle.setAttribute("cx", String(x));
    circle.setAttribute("cy", String(y));
    circle.setAttribute("r", String(this.dotRadius));
    circle.setAttribute("fill", "black");
    svg.appendChild(circle);
  }
};

// src/renderer/MeasureRenderer.ts
var MeasureRenderer = class {
  constructor(measure, x, y, width, beamedAtLevel1, collisionManager, stemsDirection, displayRepeatSymbol) {
    this.measure = measure;
    this.x = x;
    this.y = y;
    this.width = width;
    this.beamedAtLevel1 = beamedAtLevel1;
    this.collisionManager = collisionManager;
    /**
     * Constructeur du renderer de mesure.
     * 
     * @param measure - Mesure à rendre
     * @param x - Position X de départ de la mesure dans le SVG
     * @param y - Position Y de départ de la mesure dans le SVG
     * @param width - Largeur allouée à la mesure
     * @param beamedAtLevel1 - Set of segmentIndex:noteIndex that are in level-1 beam groups
     * @param collisionManager - Gestionnaire de collisions pour éviter les chevauchements
     * @param stemsDirection - Direction des hampes ('up' ou 'down')
     * @param displayRepeatSymbol - Afficher le symbole % pour les mesures répétées
     */
    __publicField(this, "restRenderer");
    __publicField(this, "stemsDirection");
    __publicField(this, "displayRepeatSymbol");
    this.stemsDirection = stemsDirection === "down" ? "down" : "up";
    this.displayRepeatSymbol = displayRepeatSymbol != null ? displayRepeatSymbol : false;
    this.restRenderer = new RestRenderer(this.collisionManager);
  }
  /**
   * Dessine la mesure complète dans le SVG.
   * 
   * Cette méthode orchestre le rendu de tous les éléments de la mesure :
   * 1. Barres de mesure (gauche avec éventuelle reprise)
   * 2. Ligne de portée
   * 3. Segments d'accords avec leurs beats
   * 4. Notes et silences avec ligatures
   * 5. Barre de mesure de fin (avec éventuelle reprise ou double barre)
   * 
   * @param svg - Élément SVG parent
   * @param measureIndex - Index de la mesure dans la grille (pour numérotation)
   * @param notePositions - Tableau collectant les positions de toutes les notes (pour liaisons)
   * @param grid - Grille complète (pour contexte de signature temporelle, etc.)
   */
  drawMeasure(svg, measureIndex, notePositions, grid) {
    const leftBarX = this.x;
    const rightBarX = this.x + this.width - 2;
    if (this.measure.isRepeatStart) {
      this.drawBarWithRepeat(svg, leftBarX, this.y, 120, true);
    } else if (measureIndex === 0 || this.measure.__isLineStart) {
      this.drawBar(svg, leftBarX, this.y, 120);
    }
    const staffLineY = this.y + 80;
    const staffLine = document.createElementNS(SVG_NS, "line");
    staffLine.setAttribute("x1", (this.x + 10).toString());
    staffLine.setAttribute("y1", staffLineY.toString());
    staffLine.setAttribute("x2", (this.x + this.width - 10).toString());
    staffLine.setAttribute("y2", staffLineY.toString());
    staffLine.setAttribute("stroke", "#000");
    staffLine.setAttribute("stroke-width", "1");
    svg.appendChild(staffLine);
    if (this.displayRepeatSymbol && this.measure.isRepeat) {
      this.drawRepeatSymbol(svg);
      this.drawChordName(svg, this.measure.chord, this.x + 30);
      this.drawRightBarline(svg, rightBarX, this.y, 120);
      return;
    }
    const segments = this.measure.chordSegments || [{ chord: this.measure.chord, beats: this.measure.beats }];
    const segmentNoteCursor = new Array(segments.length).fill(0);
    const totalBeats = segments.reduce((s, seg) => s + (seg.beats ? seg.beats.length : 0), 0) || 1;
    const separatorWidth = 12;
    const separatorsCount = segments.reduce((cnt, seg, idx) => cnt + (idx > 0 && seg.leadingSpace ? 1 : 0), 0);
    const innerPaddingPerSegment = 20;
    const totalInnerPadding = innerPaddingPerSegment * segments.length;
    const totalSeparatorPixels = separatorsCount * separatorWidth;
    const availableForBeatCells = Math.max(0, this.width - totalInnerPadding - totalSeparatorPixels);
    const headHalfMax = 6;
    const valueMinSpacing = (v) => {
      if (v >= 64) return 16;
      if (v >= 32) return 20;
      if (v >= 16) return 26;
      if (v >= 8) return 24;
      return 20;
    };
    const requiredBeatWidth = (beat) => {
      var _a;
      const noteCount = ((_a = beat == null ? void 0 : beat.notes) == null ? void 0 : _a.length) || 0;
      if (noteCount <= 1) return 28 + 10 + headHalfMax;
      const spacing = Math.max(
        ...beat.notes.map((n) => {
          const base = valueMinSpacing(n.value);
          return n.isRest ? base + 4 : base;
        })
      );
      return 10 + 10 + headHalfMax + (noteCount - 1) * spacing + 8;
    };
    const perSegmentRequired = segments.map((seg) => {
      const reqs = (seg.beats || []).map((b) => requiredBeatWidth(b));
      return reqs.reduce((a, b) => a + b, 0);
    });
    const totalRequiredAcrossSegments = perSegmentRequired.reduce((a, b) => a + b, 0) || 1;
    let currentX = this.x;
    for (let segmentIndex = 0; segmentIndex < segments.length; segmentIndex++) {
      const segment = segments[segmentIndex];
      if (segmentIndex > 0 && segment.leadingSpace) {
        currentX += separatorWidth;
      }
      const segBeatCount = segment.beats.length || 1;
      const reqPerBeat = segment.beats.map((b) => requiredBeatWidth(b));
      const reqSum = reqPerBeat.reduce((a, b) => a + b, 0) || 1;
      const segmentBeatsWidth = availableForBeatCells * (perSegmentRequired[segmentIndex] / totalRequiredAcrossSegments);
      const segmentWidth = segmentBeatsWidth + innerPaddingPerSegment;
      const segmentX = currentX + 10;
      const beatsWidth = segmentWidth - innerPaddingPerSegment;
      let beatCursorX = segmentX;
      segment.beats.forEach((beat, beatIndex) => {
        const beatWidth = reqPerBeat[beatIndex] / reqSum * beatsWidth;
        const beatX = beatCursorX;
        const firstNoteX = this.drawRhythm(svg, beat, beatX, staffLineY, beatWidth, measureIndex, segmentIndex, beatIndex, notePositions, segmentNoteCursor);
        if (firstNoteX !== null && beatIndex === 0 && segment.chord) {
          const chordX = firstNoteX;
          const chordY = this.y + 40;
          const fontSize = 22;
          const chordWidth = segment.chord.length * fontSize * 0.6;
          let finalY = chordY;
          if (this.collisionManager) {
            const chordBBox = {
              x: chordX - chordWidth / 2,
              y: chordY - fontSize,
              width: chordWidth,
              height: fontSize + 4
            };
            if (this.collisionManager.hasCollision(chordBBox)) {
              const adjustedPos = this.collisionManager.findFreePosition(
                chordBBox,
                "vertical",
                ["chord"]
              );
              if (adjustedPos) {
                finalY = adjustedPos.y + fontSize;
              }
            }
            this.collisionManager.registerElement("chord", {
              x: chordX - chordWidth / 2,
              y: finalY - fontSize,
              width: chordWidth,
              height: fontSize + 4
            }, 5, { chord: segment.chord, measureIndex, segmentIndex });
          }
          const chordText = this.createText(segment.chord, chordX, finalY, "22px", "bold");
          chordText.setAttribute("text-anchor", "middle");
          chordText.setAttribute("font-family", "Arial, sans-serif");
          svg.appendChild(chordText);
        }
        beatCursorX += beatWidth;
      });
      currentX += segmentWidth;
    }
    if (this.measure.isRepeatEnd) {
      this.drawBarWithRepeat(svg, rightBarX, this.y, 120, false);
    } else if (this.measure.barline || measureIndex === grid.measures.length - 1) {
      this.drawBar(svg, rightBarX, this.y, 120);
    }
  }
  drawRhythm(svg, beat, x, staffLineY, width, measureIndex, chordIndex, beatIndex, notePositions, segmentNoteCursor) {
    const beats = [beat];
    const beatWidth = width;
    let currentX = x;
    let firstNoteX = null;
    const first = this.drawBeat(svg, beat, currentX, staffLineY, beatWidth, measureIndex, chordIndex, beatIndex, notePositions, segmentNoteCursor);
    if (first !== null) firstNoteX = first;
    return firstNoteX;
  }
  drawBeat(svg, beat, x, staffLineY, width, measureIndex, chordIndex, beatIndex, notePositions, segmentNoteCursor) {
    if (!beat || beat.notes.length === 0) return null;
    const hasBeamableNotes = beat.notes.some((n) => n.value >= 8 || n.tieStart || n.tieEnd || n.tieToVoid || n.tieFromVoid);
    const noteCount = beat.notes.length;
    let firstNoteX = null;
    const innerLeft = 10;
    const innerRight = 10;
    const headHalfMax = 6;
    const startX = x + innerLeft;
    const endLimit = x + width - innerRight - headHalfMax;
    const tupletGroups = [];
    const seenTupletGroups = /* @__PURE__ */ new Set();
    beat.notes.forEach((note, i) => {
      if (note.tuplet && !seenTupletGroups.has(note.tuplet.groupId)) {
        seenTupletGroups.add(note.tuplet.groupId);
        const groupNotes = beat.notes.filter((n) => n.tuplet && n.tuplet.groupId === note.tuplet.groupId);
        const startIdx = beat.notes.findIndex((n) => n.tuplet && n.tuplet.groupId === note.tuplet.groupId);
        tupletGroups.push({
          startIndex: startIdx,
          endIndex: startIdx + groupNotes.length - 1,
          count: note.tuplet.count,
          groupId: note.tuplet.groupId,
          ratio: note.tuplet.ratio
        });
      }
    });
    const notePositionsX = [];
    const densestSpacing = Math.max(...beat.notes.map((n) => {
      if (n.isRest) return 20;
      const v = n.value;
      if (v >= 64) return 16;
      if (v >= 32) return 20;
      if (v >= 16) return 26;
      if (v >= 8) return 24;
      return 20;
    }));
    const availableSpan = Math.max(0, endLimit - startX);
    const gapCount = Math.max(0, noteCount - 1);
    const gapFactors = [];
    for (let g = 0; g < gapCount; g++) {
      const inSameTuplet = tupletGroups.some((T) => g >= T.startIndex && g + 1 <= T.endIndex);
      gapFactors.push(inSameTuplet ? 0.85 : 1);
    }
    const desiredGaps = gapFactors.map((f) => densestSpacing * f);
    const desiredTotal = desiredGaps.reduce((a, b) => a + b, 0);
    const scale = desiredTotal > 0 ? Math.min(1, availableSpan / desiredTotal) : 1;
    const finalGaps = desiredGaps.map((g) => g * scale);
    let cursorX = startX;
    for (let i = 0; i < noteCount; i++) {
      notePositionsX.push(cursorX);
      if (i < gapCount) cursorX += finalGaps[i];
    }
    beat.notes.forEach((nv, noteIndex) => {
      var _a;
      let noteX;
      if (noteCount === 1 && nv.isRest && nv.value === 1) {
        noteX = x + width / 2;
      } else {
        noteX = notePositionsX[noteIndex];
      }
      if (nv.isRest) {
        this.restRenderer.drawRest(svg, nv, noteX, staffLineY);
        segmentNoteCursor[chordIndex]++;
        if (firstNoteX === null) firstNoteX = noteX;
        return;
      }
      const localIndexInSegment = segmentNoteCursor[chordIndex];
      const isInPrimaryBeam = !!((_a = this.beamedAtLevel1) == null ? void 0 : _a.has(`${chordIndex}:${localIndexInSegment}`));
      const needsFlag = nv.value >= 8 && !isInPrimaryBeam;
      const stemCoords = this.drawSingleNoteWithoutBeam(svg, nv, noteX, staffLineY, needsFlag);
      if (firstNoteX === null) firstNoteX = noteX;
      let headLeftX;
      let headRightX;
      if (nv.value === 1 || nv.value === 2) {
        const diamondSize = 6;
        headLeftX = noteX - diamondSize;
        headRightX = noteX + diamondSize;
      } else {
        const slashHalf = 10 / 2;
        headLeftX = noteX - slashHalf;
        headRightX = noteX + slashHalf;
      }
      const hasStem = nv.value >= 2;
      const stemTopY = stemCoords.stemTopY;
      const stemBottomY = stemCoords.stemBottomY;
      notePositions.push({
        x: noteX,
        y: staffLineY,
        headLeftX,
        headRightX,
        measureIndex,
        chordIndex,
        beatIndex,
        noteIndex,
        segmentNoteIndex: segmentNoteCursor[chordIndex]++,
        tieStart: !!nv.tieStart,
        tieEnd: !!nv.tieEnd,
        tieToVoid: !!nv.tieToVoid,
        tieFromVoid: !!nv.tieFromVoid,
        globalTimeIndex: measureIndex * 1e6 + chordIndex * 1e4 + beatIndex * 100 + noteIndex,
        stemTopY,
        stemBottomY,
        value: nv.value
      });
      if (this.collisionManager) {
        const noteHeadBBox = {
          x: headLeftX,
          y: staffLineY - 12,
          width: headRightX - headLeftX,
          height: 24
        };
        this.collisionManager.registerElement("note", noteHeadBBox, 6, { value: nv.value, dotted: nv.dotted, measureIndex, chordIndex, beatIndex, noteIndex });
        if (hasStem && stemTopY !== void 0 && stemBottomY !== void 0) {
          const stemBBox = {
            x: noteX - 3,
            // approximate stem x based on drawStem logic
            y: stemTopY,
            width: 3,
            height: stemBottomY - stemTopY
          };
          this.collisionManager.registerElement("stem", stemBBox, 5, { measureIndex, chordIndex, beatIndex, noteIndex });
        }
      }
    });
    tupletGroups.forEach((tupletGroup) => {
      const tupletStartX = notePositionsX[tupletGroup.startIndex];
      const tupletEndX = notePositionsX[tupletGroup.endIndex];
      const bracketY = staffLineY - 15;
      const bracket = document.createElementNS(SVG_NS, "line");
      bracket.setAttribute("x1", String(tupletStartX));
      bracket.setAttribute("y1", String(bracketY));
      bracket.setAttribute("x2", String(tupletEndX));
      bracket.setAttribute("y2", String(bracketY));
      bracket.setAttribute("stroke", "#000");
      bracket.setAttribute("stroke-width", "1");
      svg.appendChild(bracket);
      const leftBar = document.createElementNS(SVG_NS, "line");
      leftBar.setAttribute("x1", String(tupletStartX));
      leftBar.setAttribute("y1", String(bracketY));
      leftBar.setAttribute("x2", String(tupletStartX));
      leftBar.setAttribute("y2", String(bracketY + 5));
      leftBar.setAttribute("stroke", "#000");
      leftBar.setAttribute("stroke-width", "1");
      svg.appendChild(leftBar);
      const rightBar = document.createElementNS(SVG_NS, "line");
      rightBar.setAttribute("x1", String(tupletEndX));
      rightBar.setAttribute("y1", String(bracketY));
      rightBar.setAttribute("x2", String(tupletEndX));
      rightBar.setAttribute("y2", String(bracketY + 5));
      rightBar.setAttribute("stroke", "#000");
      rightBar.setAttribute("stroke-width", "1");
      svg.appendChild(rightBar);
      if (this.collisionManager) {
        const bracketBBox = {
          x: tupletStartX,
          y: bracketY - 6,
          width: tupletEndX - tupletStartX,
          height: 12
        };
        this.collisionManager.registerElement("tuplet-bracket", bracketBBox, 4, { measureIndex, chordIndex, beatIndex });
      }
      const centerX = (tupletStartX + tupletEndX) / 2;
      let tupletTextY = bracketY - 3;
      const text = document.createElementNS(SVG_NS, "text");
      text.setAttribute("x", String(centerX));
      text.setAttribute("y", String(tupletTextY));
      text.setAttribute("font-size", "10");
      text.setAttribute("font-weight", "bold");
      text.setAttribute("text-anchor", "middle");
      if (tupletGroup.ratio) {
        text.textContent = `${tupletGroup.ratio.numerator}:${tupletGroup.ratio.denominator}`;
      } else {
        text.textContent = String(tupletGroup.count);
      }
      if (this.collisionManager) {
        const textWidth = (text.textContent || "").length * 6;
        let numberBBox = {
          x: centerX - textWidth / 2,
          y: tupletTextY - 10,
          width: textWidth,
          height: 12
        };
        if (this.collisionManager.hasCollision(numberBBox, ["tuplet-bracket", "tuplet-number"])) {
          const adjusted = this.collisionManager.findFreePosition(numberBBox, "vertical", ["tuplet-number"]);
          if (adjusted) {
            tupletTextY = adjusted.y + 10;
            text.setAttribute("y", String(tupletTextY));
            numberBBox = { ...numberBBox, y: adjusted.y };
          }
        }
        this.collisionManager.registerElement("tuplet-number", numberBBox, 7, { text: text.textContent, measureIndex, chordIndex, beatIndex });
      }
      svg.appendChild(text);
    });
    return firstNoteX;
  }
  drawSingleNote(svg, nv, x, staffLineY, width) {
    if (nv.isRest) {
      this.restRenderer.drawRest(svg, nv, x, staffLineY);
      return x;
    }
    const centerX = x;
    let stemInfo;
    if (nv.value === 1) {
      this.drawDiamondNoteHead(svg, centerX, staffLineY, true);
    } else if (nv.value === 2) {
      this.drawDiamondNoteHead(svg, centerX, staffLineY, true);
      stemInfo = this.drawStemWithDirection(svg, centerX, staffLineY, 25, this.stemsDirection);
    } else {
      this.drawSlash(svg, centerX, staffLineY);
      stemInfo = this.drawStemWithDirection(svg, centerX, staffLineY, 25, this.stemsDirection);
      const level = nv.value >= 64 ? 4 : nv.value >= 32 ? 3 : nv.value >= 16 ? 2 : nv.value >= 8 ? 1 : 0;
      if (level > 0 && stemInfo) {
        this.drawFlag(svg, stemInfo, level, this.stemsDirection);
      }
    }
    if (nv.dotted) {
      const dot = document.createElementNS(SVG_NS, "circle");
      dot.setAttribute("cx", (centerX + 10).toString());
      dot.setAttribute("cy", (staffLineY - 4).toString());
      dot.setAttribute("r", "1.5");
      dot.setAttribute("fill", "#000");
      dot.setAttribute("data-cg-dot", "1");
      svg.appendChild(dot);
      if (this.collisionManager) {
        const cx = centerX + 10;
        const cy = staffLineY - 4;
        this.collisionManager.registerElement("dot", { x: cx - 2, y: cy - 2, width: 4, height: 4 }, 9, { value: nv.value, dotted: true });
      }
    }
    return centerX;
  }
  /**
   * Draw a single note without beams or flags (for analyzer path).
   * Analyzer overlay will handle beams; this just draws head and stem.
   * Retourne les coordonnées de la hampe si elle existe.
   */
  drawSingleNoteWithoutBeam(svg, nv, x, staffLineY, drawFlagsForIsolated = false) {
    if (nv.isRest) {
      this.restRenderer.drawRest(svg, nv, x, staffLineY);
      return {};
    }
    let stemInfo;
    if (nv.value === 1) {
      this.drawDiamondNoteHead(svg, x, staffLineY, true);
    } else if (nv.value === 2) {
      this.drawDiamondNoteHead(svg, x, staffLineY, true);
      stemInfo = this.drawStemWithDirection(svg, x, staffLineY, 25, this.stemsDirection);
    } else {
      this.drawSlash(svg, x, staffLineY);
      stemInfo = this.drawStemWithDirection(svg, x, staffLineY, 25, this.stemsDirection);
      if (drawFlagsForIsolated) {
        const level = nv.value >= 64 ? 4 : nv.value >= 32 ? 3 : nv.value >= 16 ? 2 : nv.value >= 8 ? 1 : 0;
        if (level > 0 && stemInfo) {
          this.drawFlag(svg, stemInfo, level, this.stemsDirection);
        }
      }
    }
    if (nv.dotted) {
      const dot = document.createElementNS(SVG_NS, "circle");
      dot.setAttribute("cx", (x + 10).toString());
      dot.setAttribute("cy", (staffLineY - 4).toString());
      dot.setAttribute("r", "1.5");
      dot.setAttribute("fill", "#000");
      dot.setAttribute("data-cg-dot", "1");
      svg.appendChild(dot);
      if (this.collisionManager) {
        const cx = x + 10;
        const cy = staffLineY - 4;
        this.collisionManager.registerElement("dot", { x: cx - 2, y: cy - 2, width: 4, height: 4 }, 9, { value: nv.value, dotted: true });
      }
    }
    return stemInfo ? { stemTopY: stemInfo.topY, stemBottomY: stemInfo.bottomY } : {};
  }
  /**
   * Dessine une hampe orientée selon stemsDirection ('up' ou 'down').
   * Retourne les coordonnées de la hampe : x, topY (point le plus haut), bottomY (point le plus bas)
   */
  drawStemWithDirection(svg, x, y, height, direction) {
    const slashLength = 10;
    const stemStartX = direction === "up" ? x + slashLength / 2 : x - slashLength / 2;
    let stemStartY, stemEndY;
    if (direction === "up") {
      stemStartY = y - slashLength / 2;
      stemEndY = stemStartY - height;
    } else {
      stemStartY = y + slashLength / 2;
      stemEndY = stemStartY + height;
    }
    const stem = document.createElementNS(SVG_NS, "line");
    stem.setAttribute("x1", stemStartX.toString());
    stem.setAttribute("y1", stemStartY.toString());
    stem.setAttribute("x2", stemStartX.toString());
    stem.setAttribute("y2", stemEndY.toString());
    stem.setAttribute("stroke", "#000");
    stem.setAttribute("stroke-width", "2");
    svg.appendChild(stem);
    return {
      x: stemStartX,
      topY: Math.min(stemStartY, stemEndY),
      bottomY: Math.max(stemStartY, stemEndY)
    };
  }
  drawDiamondNoteHead(svg, x, y, hollow) {
    const diamondSize = 6;
    const diamond = document.createElementNS(SVG_NS, "polygon");
    const points = [[x, y - diamondSize], [x + diamondSize, y], [x, y + diamondSize], [x - diamondSize, y]];
    diamond.setAttribute("points", points.map((p) => `${p[0]},${p[1]}`).join(" "));
    diamond.setAttribute("fill", hollow ? "white" : "black");
    diamond.setAttribute("stroke", "#000");
    diamond.setAttribute("stroke-width", "1");
    svg.appendChild(diamond);
  }
  drawSlash(svg, x, y) {
    const slashLength = 10;
    const slash = document.createElementNS(SVG_NS, "line");
    slash.setAttribute("x1", (x + slashLength / 2).toString());
    slash.setAttribute("y1", (y - slashLength / 2).toString());
    slash.setAttribute("x2", (x - slashLength / 2).toString());
    slash.setAttribute("y2", (y + slashLength / 2).toString());
    slash.setAttribute("stroke", "#000");
    slash.setAttribute("stroke-width", "3");
    svg.appendChild(slash);
  }
  drawStem(svg, x, y, height) {
    const slashLength = 10;
    const stemStartX = x - slashLength / 2 + 2;
    const stemStartY = y + slashLength / 2;
    const stem = document.createElementNS(SVG_NS, "line");
    stem.setAttribute("x1", stemStartX.toString());
    stem.setAttribute("y1", stemStartY.toString());
    stem.setAttribute("x2", stemStartX.toString());
    stem.setAttribute("y2", (stemStartY + height).toString());
    stem.setAttribute("stroke", "#000");
    stem.setAttribute("stroke-width", "2");
    svg.appendChild(stem);
    return { x: stemStartX, topY: stemStartY, bottomY: stemStartY + height };
  }
  drawFlag(svg, stem, count, direction) {
    const flagSpacing = 10;
    for (let i = 0; i < count; i++) {
      const flag = document.createElementNS(SVG_NS, "path");
      if (direction === "up") {
        const attachY = stem.topY + i * flagSpacing;
        flag.setAttribute("d", `M ${stem.x} ${attachY} Q ${stem.x + 10} ${attachY + 5} ${stem.x + 8} ${attachY + 12}`);
      } else {
        const attachY = stem.bottomY - i * flagSpacing;
        flag.setAttribute("d", `M ${stem.x} ${attachY} Q ${stem.x - 10} ${attachY - 5} ${stem.x - 8} ${attachY - 12}`);
      }
      flag.setAttribute("stroke", "#000");
      flag.setAttribute("stroke-width", "2");
      flag.setAttribute("fill", "none");
      svg.appendChild(flag);
    }
  }
  drawBar(svg, x, y, height) {
    const line = document.createElementNS(SVG_NS, "line");
    line.setAttribute("x1", x.toString());
    line.setAttribute("y1", y.toString());
    line.setAttribute("x2", x.toString());
    line.setAttribute("y2", (y + height).toString());
    line.setAttribute("stroke", "#000");
    line.setAttribute("stroke-width", "1.5");
    svg.appendChild(line);
  }
  drawBarWithRepeat(svg, x, y, height, isStart) {
    this.drawDoubleBar(svg, x, y, height);
    const dotOffset = isStart ? 12 : -12;
    const staffLineY = y + 80;
    const dotSpacing = 12;
    const dot1Y = staffLineY - dotSpacing;
    const dot2Y = staffLineY + dotSpacing;
    [dot1Y, dot2Y].forEach((dotY) => {
      const circle = document.createElementNS(SVG_NS, "circle");
      const dotX = x + dotOffset;
      circle.setAttribute("cx", dotX.toString());
      circle.setAttribute("cy", dotY.toString());
      circle.setAttribute("r", "2");
      circle.setAttribute("fill", "#000");
      svg.appendChild(circle);
      if (this.collisionManager) {
        this.collisionManager.registerElement("dot", {
          x: dotX - 3,
          // Extend collision box a bit
          y: dotY - 3,
          width: 6,
          height: 6
        }, 8, { type: "repeat-barline" });
      }
    });
  }
  drawDoubleBar(svg, x, y, height) {
    const bar1 = document.createElementNS(SVG_NS, "line");
    bar1.setAttribute("x1", x.toString());
    bar1.setAttribute("y1", y.toString());
    bar1.setAttribute("x2", x.toString());
    bar1.setAttribute("y2", (y + height).toString());
    bar1.setAttribute("stroke", "#000");
    bar1.setAttribute("stroke-width", "1.5");
    svg.appendChild(bar1);
    const bar2 = document.createElementNS(SVG_NS, "line");
    bar2.setAttribute("x1", (x + 6).toString());
    bar2.setAttribute("y1", y.toString());
    bar2.setAttribute("x2", (x + 6).toString());
    bar2.setAttribute("y2", (y + height).toString());
    bar2.setAttribute("stroke", "#000");
    bar2.setAttribute("stroke-width", "1.5");
    svg.appendChild(bar2);
  }
  /**
   * Draw the repeat symbol (%) in the center of the measure.
   * Uses the official SVG path for a classical measure repeat symbol.
   */
  drawRepeatSymbol(svg) {
    const centerX = this.x + this.width / 2;
    const centerY = this.y + 80;
    const targetHeight = 30;
    const originalHeight = 178;
    const originalWidth = 188;
    const scale = targetHeight / originalHeight;
    const symbolWidth = originalWidth * scale;
    const symbolHeight = targetHeight;
    const translateX = centerX - symbolWidth / 2;
    const translateY = centerY - symbolHeight / 2 - 2;
    const group = document.createElementNS(SVG_NS, "g");
    group.setAttribute("data-repeat-symbol", "true");
    group.setAttribute("transform", `translate(${translateX.toFixed(2)},${translateY.toFixed(2)}) scale(${scale.toFixed(4)})`);
    const path = document.createElementNS(SVG_NS, "path");
    path.setAttribute("d", "M 0.29640036,177.3364 35.741505,135.44902 71.186609,93.561637 82.730763,80.33404 116.29431,40.651251 149.85784,0.96846227 h 37.46642 L 153.76072,40.651251 120.19718,80.33404 108.65303,93.561637 73.207926,135.44902 37.762822,177.3364 Z M 131.5485,152.77085 c -3.23819,-3.81078 -5.88759,-10.61356 -5.88759,-15.11723 0,-4.50368 2.6494,-11.30646 5.88759,-15.11724 3.23814,-3.81083 9.01868,-6.92875 12.84561,-6.92875 3.82693,0 9.60748,3.11792 12.84563,6.92875 3.23818,3.81078 5.88758,10.61356 5.88758,15.11724 0,4.50367 -2.6494,11.30645 -5.88758,15.11723 -3.23815,3.81083 -9.0187,6.92875 -12.84563,6.92875 -3.82693,0 -9.60747,-3.11792 -12.84561,-6.92875 z M 34.135803,51.359299 C 30.897632,47.548517 28.24822,40.74574 28.24822,36.242052 c 0,-4.503687 2.649412,-11.306465 5.887583,-15.117246 11.362479,-13.3718214 31.57884,-3.693983 31.57884,15.117246 0,4.503688 -2.649413,11.306465 -5.887583,15.117247 -3.238167,3.810826 -9.018699,6.928747 -12.845629,6.928747 -3.826929,0 -9.607461,-3.117921 -12.845628,-6.928747 z");
    path.setAttribute("fill", "#444");
    group.appendChild(path);
    svg.appendChild(group);
  }
  /**
   * Draw chord name above the measure.
   */
  drawChordName(svg, chord, xPosition) {
    if (!chord) return;
    const chordX = xPosition !== void 0 ? xPosition : this.x + this.width / 2;
    const chordY = this.y + 40;
    const fontSize = 22;
    const chordText = this.createText(chord, chordX, chordY, `${fontSize}px`, "bold");
    chordText.setAttribute("text-anchor", "middle");
    chordText.setAttribute("font-family", "Arial, sans-serif");
    svg.appendChild(chordText);
  }
  /**
   * Draw the right barline of the measure.
   */
  drawRightBarline(svg, x, y, height) {
    if (this.measure.isRepeatEnd) {
      this.drawBarWithRepeat(svg, x, y, height, false);
    } else {
      this.drawBar(svg, x, y, height);
    }
  }
  createText(text, x, y, size, weight = "normal") {
    const textEl = document.createElementNS(SVG_NS, "text");
    textEl.setAttribute("x", x.toString());
    textEl.setAttribute("y", y.toString());
    textEl.setAttribute("font-family", "Arial, sans-serif");
    textEl.setAttribute("font-size", size);
    textEl.setAttribute("font-weight", weight);
    textEl.setAttribute("fill", "#000");
    textEl.textContent = text;
    return textEl;
  }
};

// src/utils/TieManager.ts
var TieManager = class {
  constructor() {
    // pending ties saved when a tie continues beyond the rendered area (e.g. line break)
    __publicField(this, "pending", []);
  }
  /**
   * Ajoute une liaison en attente de résolution.
   * 
   * Utilisé lorsqu'une note se termine par une liaison "to void" en fin de ligne.
   * 
   * @param measureIndex - Index de la mesure contenant la note de départ
   * @param x - Position X de la fin de la liaison
   * @param y - Position Y de la fin de la liaison
   */
  addPendingTie(measureIndex, x, y) {
    this.pending.push({ measureIndex, x, y });
  }
  /**
   * Tente de résoudre une liaison en attente pour une note commençant par "from void".
   * 
   * Recherche une liaison en attente dont l'index de mesure est strictement inférieur
   * à celui donné (car la liaison vient d'une mesure précédente).
   * 
   * @param measureIndex - Index de la mesure contenant la note d'arrivée
   * @returns La liaison en attente (et la retire de la liste) ou null si aucune
   */
  resolvePendingFor(measureIndex) {
    for (let i = 0; i < this.pending.length; i++) {
      if (this.pending[i].measureIndex < measureIndex) {
        const p = this.pending.splice(i, 1)[0];
        return p;
      }
    }
    return null;
  }
  /**
   * Efface toutes les liaisons en attente.
   * 
   * Utilisé pour réinitialiser le gestionnaire entre différents rendus.
   */
  clearPending() {
    this.pending = [];
  }
};

// src/analyzer/MusicAnalyzer.ts
var DebugLogger2;
try {
  DebugLogger2 = (init_DebugLogger(), __toCommonJS(DebugLogger_exports)).DebugLogger;
} catch (e) {
  DebugLogger2 = {
    log: () => {
    },
    warn: () => {
    },
    error: () => {
    }
  };
}
var MusicAnalyzer = class {
  /**
   * Analyze a parsed measure and determine beam groups
   * 
   * This is the main entry point for musical analysis. It takes a measure
   * that has been syntactically parsed and adds musical semantic information.
   * 
   * @param measure - Parsed measure from ChordGridParser
   * @returns Analyzed measure with beam groups calculated
   */
  analyze(measure) {
    DebugLogger2.log("\u{1F3BC} MusicAnalyzer: Starting analysis", {
      segments: measure.segments.length
    });
    const allNotes = this.flattenNotes(measure);
    DebugLogger2.log("\u{1F4CB} Flattened notes", {
      totalNotes: allNotes.length,
      beamableCount: allNotes.filter((n) => this.isBeamable(n)).length
    });
    const beamGroups = this.analyzeBeams(allNotes, measure);
    DebugLogger2.log("\u2705 Analysis complete", {
      beamGroupsCreated: beamGroups.length
    });
    return {
      ...measure,
      beamGroups,
      allNotes
    };
  }
  /**
   * Determine the actual grouping mode (resolve 'auto' to 'binary' or 'ternary')
   * 
   * Rules:
   * - noauto: user controls grouping via spaces (no auto-breaking)
   * - binary: group by 2 eighths (1.0 quarter)
   * - ternary: group by 3 eighths (1.5 quarters)
   * - auto: detect from time signature
   *   - denominator <= 4: binary (quarter-note based, group by 2)
   *   - denominator >= 8 with numerator in {3,6,9,12}: ternary (dotted-quarter based, group by 3)
   *   - else: irregular (space-based grouping, no auto-breaking)
   */
  resolveGroupingMode(timeSignature) {
    if (timeSignature.groupingMode === "noauto") {
      return "irregular";
    }
    if (timeSignature.groupingMode === "binary") {
      return "binary";
    }
    if (timeSignature.groupingMode === "ternary") {
      return "ternary";
    }
    const { numerator, denominator } = timeSignature;
    if (denominator <= 4) {
      return "binary";
    }
    if (denominator >= 8 && [3, 6, 9, 12].includes(numerator)) {
      return "ternary";
    }
    return "irregular";
  }
  /**
   * Calculate note duration in quarter-note units
   */
  getNoteDuration(note) {
    var _a;
    let duration = 4 / note.value;
    if (note.dotted) {
      duration *= 1.5;
    }
    if ((_a = note.tuplet) == null ? void 0 : _a.ratio) {
      const { numerator, denominator } = note.tuplet.ratio;
      duration *= denominator / numerator;
    }
    return duration;
  }
  /**
   * Flatten all notes from all segments into a single array with positions and timing
   */
  flattenNotes(measure) {
    const allNotes = [];
    let absoluteIndex = 0;
    let quarterPosition = 0;
    measure.segments.forEach((segment, segmentIndex) => {
      segment.notes.forEach((note, noteIndexInSegment) => {
        const duration = this.getNoteDuration(note);
        allNotes.push({
          ...note,
          segmentIndex,
          noteIndexInSegment,
          absoluteIndex: absoluteIndex++,
          quarterStart: quarterPosition,
          quarterDuration: duration
        });
        quarterPosition += duration;
      });
    });
    return allNotes;
  }
  /**
   * Analyze beam groups for the entire measure
   * 
   * This method groups beamable notes together, respecting:
   * - Segment boundaries with leadingSpace=true (break beams)
   * - Rests (always break beams)
   * - Musical notation rules
   */
  analyzeBeams(allNotes, measure) {
    const beamGroups = [];
    const beamableIdxs = [];
    for (let i = 0; i < allNotes.length; i++) {
      if (this.isBeamable(allNotes[i])) beamableIdxs.push(i);
    }
    if (beamableIdxs.length === 0) return beamGroups;
    DebugLogger2.log("\u{1F3B5} Analyzing beams", {
      totalBeamable: beamableIdxs.length,
      notes: beamableIdxs.map((idx) => ({
        index: idx,
        segmentIndex: allNotes[idx].segmentIndex,
        value: allNotes[idx].value,
        absoluteIndex: allNotes[idx].absoluteIndex
      }))
    });
    const segments = [];
    let seg = [beamableIdxs[0]];
    for (let k = 1; k < beamableIdxs.length; k++) {
      const a = beamableIdxs[k - 1];
      const b = beamableIdxs[k];
      if (this.isHardBreakBetween(allNotes[a], allNotes[b], measure)) {
        segments.push(seg);
        seg = [b];
      } else {
        seg.push(b);
      }
    }
    if (seg.length) segments.push(seg);
    DebugLogger2.log("\u{1F3B5} Beam segments after hard breaks", {
      segmentCount: segments.length,
      segments: segments.map((s) => s.map((idx) => allNotes[idx].absoluteIndex))
    });
    for (const noteIndices of segments) {
      if (noteIndices.length === 0) continue;
      const blocks = [];
      for (let j = 0; j < noteIndices.length - 1; j++) {
        const aIdx = noteIndices[j];
        const bIdx = noteIndices[j + 1];
        const aAbs = allNotes[aIdx].absoluteIndex;
        const bAbs = allNotes[bIdx].absoluteIndex;
        let blockFromLevel = Infinity;
        const aLevel = this.getBeamLevel(allNotes[aIdx].value);
        const bLevel = this.getBeamLevel(allNotes[bIdx].value);
        const notesLevel = Math.min(aLevel, bLevel);
        const inTuplet = allNotes[aIdx].tuplet || allNotes[bIdx].tuplet;
        const bNote = allNotes[bIdx];
        const aNote = allNotes[aIdx];
        if (bNote.hasLeadingSpace && !aNote.forcedBeamThroughTie) {
          let minGroupLevel = Infinity;
          for (let lookback = j; lookback >= 0; lookback--) {
            const prevNote = allNotes[noteIndices[lookback]];
            const prevLevel = this.getBeamLevel(prevNote.value);
            minGroupLevel = Math.min(minGroupLevel, prevLevel);
            if (lookback < j && prevNote.hasLeadingSpace) break;
          }
          if (minGroupLevel < Infinity) {
            blockFromLevel = Math.min(blockFromLevel, Math.max(minGroupLevel, 2));
          }
        }
        for (let t = aAbs + 1; t < bAbs; t++) {
          const mid = allNotes.find((n) => n.absoluteIndex === t);
          if (mid && mid.isRest) {
            const restLevel = this.getBeamLevel(mid.value);
            if (inTuplet) {
              if (restLevel < notesLevel) {
                blockFromLevel = Math.min(blockFromLevel, notesLevel + 1);
              } else {
                blockFromLevel = Math.min(blockFromLevel, restLevel);
              }
            } else {
              if (restLevel === notesLevel - 1) {
                blockFromLevel = Math.min(blockFromLevel, notesLevel);
              } else {
                blockFromLevel = Math.min(blockFromLevel, restLevel);
              }
            }
          }
        }
        blocks.push(blockFromLevel);
      }
      this.createBeamGroupsForNotes(noteIndices, allNotes, beamGroups, blocks);
    }
    return beamGroups;
  }
  /**
   * Determine if beam should break at this position
   */
  shouldBreakBeam(allNotes, index, measure) {
    var _a, _b;
    if (index >= allNotes.length - 1) return false;
    const current = allNotes[index];
    const next = allNotes[index + 1];
    if (current.segmentIndex === next.segmentIndex) {
      const currentBeat = (_a = current.beatIndex) != null ? _a : 0;
      const nextBeat = (_b = next.beatIndex) != null ? _b : 0;
      if (nextBeat !== currentBeat) {
        DebugLogger2.log("\u{1F50D} Beat boundary detected", {
          segment: current.segmentIndex,
          fromBeat: currentBeat,
          toBeat: nextBeat
        });
        return true;
      }
    }
    if (next.segmentIndex > current.segmentIndex) {
      const nextSegment = measure.segments[next.segmentIndex];
      DebugLogger2.log("\u{1F50D} Checking segment boundary", {
        fromSegment: current.segmentIndex,
        toSegment: next.segmentIndex,
        nextSegmentHasLeadingSpace: nextSegment.leadingSpace
      });
      return nextSegment.leadingSpace;
    }
    return false;
  }
  /**
   * Create beam groups for a collection of notes
   * 
   * This handles multiple beam levels (8th, 16th, 32nd, 64th)
   * and creates beamlets for isolated notes.
   */
  createBeamGroupsForNotes(noteIndices, allNotes, beamGroups, blocksBetween) {
    if (noteIndices.length === 0) return;
    const maxLevel = Math.max(
      ...noteIndices.map((i) => this.getBeamLevel(allNotes[i].value))
    );
    DebugLogger2.log("\u{1F3AF} Creating beam groups", {
      noteCount: noteIndices.length,
      maxLevel
    });
    for (let level = 1; level <= maxLevel; level++) {
      let sequence = [];
      for (let gi = 0; gi < noteIndices.length; gi++) {
        const idx = noteIndices[gi];
        const noteLevel = this.getBeamLevel(allNotes[idx].value);
        const qualifies = noteLevel >= level;
        if (qualifies) {
          sequence.push(idx);
        }
        const barrierBlocks = blocksBetween && gi < noteIndices.length - 1 ? blocksBetween[gi] : Infinity;
        const cutByBarrier = gi < noteIndices.length - 1 && level >= barrierBlocks;
        if (!qualifies || cutByBarrier || gi === noteIndices.length - 1) {
          if (sequence.length > 0) {
            if (level === 1) {
              beamGroups.push({
                level,
                notes: sequence.map((i) => ({
                  segmentIndex: allNotes[i].segmentIndex,
                  noteIndex: allNotes[i].noteIndexInSegment
                })),
                isPartial: false
              });
              DebugLogger2.log(`  \u2550 Created primary beam level 1`, { notesConnected: sequence.length });
            } else {
              if (sequence.length === 1) {
                const soloIdx = sequence[0];
                const direction = this.determineBeamletDirection(soloIdx, noteIndices, allNotes);
                beamGroups.push({
                  level,
                  notes: [{
                    segmentIndex: allNotes[soloIdx].segmentIndex,
                    noteIndex: allNotes[soloIdx].noteIndexInSegment
                  }],
                  isPartial: true,
                  direction
                });
                DebugLogger2.log("  \u270F\uFE0F Created secondary beamlet", { level, direction });
              } else {
                beamGroups.push({
                  level,
                  notes: sequence.map((i) => ({
                    segmentIndex: allNotes[i].segmentIndex,
                    noteIndex: allNotes[i].noteIndexInSegment
                  })),
                  isPartial: false
                });
                DebugLogger2.log(`  \u2550 Created secondary beam level ${level}`, { notesConnected: sequence.length });
              }
            }
            sequence = [];
          }
        }
      }
    }
  }
  isHardBreakBetween(a, b, measure) {
    var _a, _b, _c, _d;
    if (a.forcedBeamThroughTie) {
      DebugLogger2.log("\u{1F517} Forced beam through tie [_]", {
        fromNote: a.absoluteIndex,
        toNote: b.absoluteIndex
      });
      return false;
    }
    if (a.segmentIndex === b.segmentIndex && ((_a = a.beatIndex) != null ? _a : -1) !== ((_b = b.beatIndex) != null ? _b : -1)) {
      const aTuplet = a.tuplet;
      const bTuplet = b.tuplet;
      if (aTuplet && bTuplet && aTuplet.groupId && aTuplet.groupId === bTuplet.groupId) {
        return false;
      }
      DebugLogger2.log("\u{1F50D} Beat boundary within segment (space)", {
        fromBeat: a.beatIndex,
        toBeat: b.beatIndex,
        segment: a.segmentIndex
      });
      return true;
    }
    if (a.segmentIndex === b.segmentIndex && ((_c = a.beatIndex) != null ? _c : -1) === ((_d = b.beatIndex) != null ? _d : -1)) {
      const aTuplet2 = a.tuplet;
      const bTuplet2 = b.tuplet;
      if (aTuplet2 && bTuplet2 && aTuplet2.groupId && aTuplet2.groupId === bTuplet2.groupId) {
        return false;
      }
      if (measure.timeSignature) {
        const resolvedMode = this.resolveGroupingMode(measure.timeSignature);
        if (resolvedMode !== "irregular" && a.quarterStart !== void 0 && b.quarterStart !== void 0) {
          const groupSize = resolvedMode === "binary" ? 1 : 1.5;
          const aGroup = Math.floor(a.quarterStart / groupSize);
          const bGroup = Math.floor(b.quarterStart / groupSize);
          if (aGroup !== bGroup) {
            DebugLogger2.log(`\u{1F3B5} Auto-break at ${resolvedMode} boundary`, {
              aStart: a.quarterStart,
              bStart: b.quarterStart,
              groupSize,
              aGroup,
              bGroup
            });
            return true;
          }
        }
      }
    }
    if (b.segmentIndex > a.segmentIndex) {
      const nextSegment = measure.segments[b.segmentIndex];
      DebugLogger2.log("\u{1F50D} Checking segment boundary", {
        fromSegment: a.segmentIndex,
        toSegment: b.segmentIndex,
        nextSegmentHasLeadingSpace: nextSegment.leadingSpace
      });
      return !!nextSegment.leadingSpace;
    }
    return false;
  }
  /**
   * Determine beamlet direction based on musical notation rules
   * 
   * Rules:
   * - After dotted note: point LEFT (completes rhythmic group)
   * - Before dotted note: point RIGHT (starts rhythmic group)
   * - Default: point toward center of group
   */
  determineBeamletDirection(noteIndex, groupIndices, allNotes) {
    const posInGroup = groupIndices.indexOf(noteIndex);
    const currentNote = allNotes[noteIndex];
    if (currentNote.hasLeadingSpace) {
      return "right";
    }
    if (posInGroup < groupIndices.length - 1) {
      const nextIdx = groupIndices[posInGroup + 1];
      const nextNote = allNotes[nextIdx];
      if (nextNote.hasLeadingSpace) {
        return "left";
      }
    }
    if (posInGroup > 0) {
      const prevIdx = groupIndices[posInGroup - 1];
      const prevNote = allNotes[prevIdx];
      if (prevNote.dotted) {
        return "left";
      }
    }
    if (posInGroup < groupIndices.length - 1) {
      const nextIdx = groupIndices[posInGroup + 1];
      const nextNote = allNotes[nextIdx];
      if (nextNote.dotted) {
        return "right";
      }
    }
    const groupCenter = (groupIndices.length - 1) / 2;
    return posInGroup < groupCenter ? "right" : "left";
  }
  /**
   * Determine if a note can be beamed (8th note or shorter, not a rest)
   */
  isBeamable(note) {
    return note.value >= 8 && !note.isRest;
  }
  /**
   * Get beam level for a note value
   * 
   * @returns 0=no beam, 1=8th, 2=16th, 3=32nd, 4=64th
   */
  getBeamLevel(value) {
    if (value >= 64) return 4;
    if (value >= 32) return 3;
    if (value >= 16) return 2;
    if (value >= 8) return 1;
    return 0;
  }
};

// src/renderer/AnalyzerBeamOverlay.ts
function drawAnalyzerBeams(svg, analyzed, measureIndex, notePositions, stemsDirection = "up") {
  const beamGap = 5;
  const level1Beamed = /* @__PURE__ */ new Set();
  for (const g of analyzed.beamGroups) {
    if (g.level === 1 && !g.isPartial && g.notes.length >= 2) {
      for (const r of g.notes) {
        level1Beamed.add(`${r.segmentIndex}:${r.noteIndex}`);
      }
    }
  }
  for (const group of analyzed.beamGroups) {
    const level = group.level;
    const refs = group.notes.map((ref) => {
      const pos = notePositions.find(
        (p) => p.measureIndex === measureIndex && p.chordIndex === ref.segmentIndex && p.segmentNoteIndex === ref.noteIndex
      );
      return { ref, pos };
    });
    const valid = refs.filter((r) => r.pos);
    if (valid.length === 0) continue;
    let beamY;
    if (stemsDirection === "up") {
      const stemTops = valid.map((v) => v.pos.stemTopY || v.pos.y - 30);
      const baseStemTop = stemTops.length ? Math.min(...stemTops) : valid[0].pos.y - 30;
      beamY = baseStemTop + (level - 1) * beamGap;
    } else {
      const stemBottoms = valid.map((v) => v.pos.stemBottomY || v.pos.y + 30);
      const baseStemBottom = stemBottoms.length ? Math.max(...stemBottoms) : valid[0].pos.y + 30;
      beamY = baseStemBottom - (level - 1) * beamGap;
    }
    if (group.isPartial) {
      const p = valid[0].pos;
      if (group.level > 1) {
        const r = group.notes[0];
        const key = `${r.segmentIndex}:${r.noteIndex}`;
        if (!level1Beamed.has(key)) {
          return;
        }
      }
      const slashLength = 10;
      const startX = stemsDirection === "up" ? p.x + slashLength / 2 : p.x - slashLength / 2;
      const beamletLength = 8;
      const endX = group.direction === "right" ? startX + beamletLength : startX - beamletLength;
      const beamlet = document.createElementNS(SVG_NS, "line");
      beamlet.setAttribute("x1", String(startX));
      beamlet.setAttribute("y1", String(beamY));
      beamlet.setAttribute("x2", String(endX));
      beamlet.setAttribute("y2", String(beamY));
      beamlet.setAttribute("stroke", "#000");
      beamlet.setAttribute("stroke-width", "2");
      svg.appendChild(beamlet);
    } else {
      const first = valid[0].pos;
      const last = valid[valid.length - 1].pos;
      const slashLength = 10;
      const startX = stemsDirection === "up" ? first.x + slashLength / 2 : first.x - slashLength / 2;
      const endX = stemsDirection === "up" ? last.x + slashLength / 2 : last.x - slashLength / 2;
      const beam = document.createElementNS(SVG_NS, "line");
      beam.setAttribute("x1", String(startX));
      beam.setAttribute("y1", String(beamY));
      beam.setAttribute("x2", String(endX));
      beam.setAttribute("y2", String(beamY));
      beam.setAttribute("stroke", "#000");
      beam.setAttribute("stroke-width", "2");
      svg.appendChild(beam);
    }
  }
}

// src/renderer/CollisionManager.ts
var CollisionManager = class {
  /**
   * Constructeur du gestionnaire de collisions.
   * 
   * @param config - Configuration optionnelle
   */
  constructor(config) {
    __publicField(this, "elements", []);
    __publicField(this, "config");
    this.config = {
      minSpacing: 2,
      chordTupletVerticalSpacing: 8,
      noteHorizontalSpacing: 4,
      debugMode: false,
      ...config
    };
  }
  /**
   * Enregistre un nouvel élément dans le gestionnaire.
   * 
   * @param type - Type de l'élément
   * @param bbox - Zone occupée par l'élément
   * @param priority - Priorité de l'élément (0 = fixe, 10 = mobile)
   * @param metadata - Métadonnées optionnelles
   */
  registerElement(type, bbox, priority = 5, metadata) {
    this.elements.push({ type, bbox, priority, metadata });
    if (this.config.debugMode) {
      console.log(`[CollisionManager] Registered ${type}`, bbox);
    }
  }
  /**
   * Vérifie si une zone entre en collision avec des éléments existants.
   * 
   * @param bbox - Zone à tester
   * @param excludeTypes - Types d'éléments à exclure de la vérification
   * @param spacing - Marge supplémentaire autour de la zone (défaut: minSpacing)
   * @returns true si collision détectée
   */
  hasCollision(bbox, excludeTypes = [], spacing) {
    const margin = spacing != null ? spacing : this.config.minSpacing;
    return this.elements.some((element) => {
      if (excludeTypes.includes(element.type)) {
        return false;
      }
      return this.boxesCollide(bbox, element.bbox, margin);
    });
  }
  /**
   * Trouve tous les éléments en collision avec une zone donnée.
   * 
   * @param bbox - Zone à tester
   * @param excludeTypes - Types d'éléments à exclure
   * @param spacing - Marge supplémentaire
   * @returns Liste des éléments en collision
   */
  findCollisions(bbox, excludeTypes = [], spacing) {
    const margin = spacing != null ? spacing : this.config.minSpacing;
    return this.elements.filter((element) => {
      if (excludeTypes.includes(element.type)) {
        return false;
      }
      return this.boxesCollide(bbox, element.bbox, margin);
    });
  }
  /**
   * Trouve une position libre pour un élément en ajustant sa position.
   * 
   * @param bbox - Zone souhaitée
   * @param direction - Direction d'ajustement préférée
   * @param excludeTypes - Types à exclure de la détection
   * @param maxAttempts - Nombre maximum de tentatives
   * @returns Nouvelle position ajustée ou null si aucune position libre trouvée
   */
  findFreePosition(bbox, direction = "vertical", excludeTypes = [], maxAttempts = 20) {
    if (!this.hasCollision(bbox, excludeTypes)) {
      return bbox;
    }
    const step = this.config.minSpacing + 2;
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      let candidate;
      if (direction === "vertical") {
        const offset = attempt % 2 === 1 ? -Math.ceil(attempt / 2) * step : Math.floor(attempt / 2) * step;
        candidate = { ...bbox, y: bbox.y + offset };
      } else if (direction === "horizontal") {
        const offset = attempt % 2 === 1 ? Math.ceil(attempt / 2) * step : -Math.floor(attempt / 2) * step;
        candidate = { ...bbox, x: bbox.x + offset };
      } else {
        const quadrant = attempt % 4;
        const distance = Math.ceil(attempt / 4) * step;
        if (quadrant === 0) candidate = { ...bbox, y: bbox.y - distance };
        else if (quadrant === 1) candidate = { ...bbox, x: bbox.x + distance };
        else if (quadrant === 2) candidate = { ...bbox, y: bbox.y + distance };
        else candidate = { ...bbox, x: bbox.x - distance };
      }
      if (!this.hasCollision(candidate, excludeTypes)) {
        if (this.config.debugMode) {
          console.log(`[CollisionManager] Found free position after ${attempt} attempts`, candidate);
        }
        return candidate;
      }
    }
    if (this.config.debugMode) {
      console.warn(`[CollisionManager] Could not find free position after ${maxAttempts} attempts`);
    }
    return null;
  }
  /**
   * Suggère un ajustement vertical optimal entre deux types d'éléments spécifiques.
   * 
   * @param elementType - Type d'élément à positionner
   * @param referenceType - Type d'élément de référence
   * @param defaultY - Position Y par défaut
   * @returns Position Y ajustée
   */
  suggestVerticalOffset(elementType, referenceType, defaultY) {
    if (elementType === "tuplet-number" && referenceType === "chord") {
      return defaultY - this.config.chordTupletVerticalSpacing;
    }
    const refElements = this.elements.filter((e) => e.type === referenceType);
    if (refElements.length === 0) {
      return defaultY;
    }
    const closest = refElements.reduce((prev, curr) => {
      const prevDist = Math.abs(prev.bbox.y - defaultY);
      const currDist = Math.abs(curr.bbox.y - defaultY);
      return currDist < prevDist ? curr : prev;
    });
    const refBottom = closest.bbox.y + closest.bbox.height;
    if (defaultY > closest.bbox.y && defaultY < refBottom) {
      return refBottom + this.config.minSpacing;
    }
    return defaultY;
  }
  /**
   * Efface tous les éléments enregistrés.
   * Utile pour réinitialiser entre différentes mesures ou lignes.
   */
  clear() {
    this.elements = [];
    if (this.config.debugMode) {
      console.log("[CollisionManager] Cleared all elements");
    }
  }
  /**
   * Efface les éléments d'un type spécifique.
   * 
   * @param type - Type d'élément à effacer
   */
  clearType(type) {
    const before = this.elements.length;
    this.elements = this.elements.filter((e) => e.type !== type);
    if (this.config.debugMode) {
      console.log(`[CollisionManager] Cleared ${before - this.elements.length} elements of type ${type}`);
    }
  }
  /**
   * Obtient tous les éléments enregistrés (lecture seule).
   * 
   * @returns Copie du tableau des éléments
   */
  getElements() {
    return [...this.elements];
  }
  /**
   * Obtient les statistiques du gestionnaire.
   * 
   * @returns Statistiques sur les éléments enregistrés
   */
  getStats() {
    const byType = {};
    this.elements.forEach((e) => {
      byType[e.type] = (byType[e.type] || 0) + 1;
    });
    return {
      total: this.elements.length,
      byType
    };
  }
  /**
   * Vérifie si deux bounding boxes se chevauchent (avec marge optionnelle).
   * 
   * @param a - Première box
   * @param b - Deuxième box
   * @param margin - Marge supplémentaire à considérer
   * @returns true si collision détectée
   */
  boxesCollide(a, b, margin = 0) {
    return !(a.x + a.width + margin < b.x || b.x + b.width + margin < a.x || a.y + a.height + margin < b.y || b.y + b.height + margin < a.y);
  }
};

// src/renderer/SVGRenderer.ts
var SVGRenderer = class {
  /**
   * Rend une grille d'accords en élément SVG.
   * 
   * @param grid - Structure ChordGrid contenant les mesures à rendre
   * @returns Élément SVG prêt à être inséré dans le DOM
   */
  /**
   * Rend une grille d'accords en élément SVG.
   * @param grid - Structure ChordGrid contenant les mesures à rendre
   * @param optionsOrStemsDirection - Options de rendu ou direction des hampes (rétro-compatibilité)
   */
  render(grid, optionsOrStemsDirection) {
    let options;
    if (typeof optionsOrStemsDirection === "string") {
      options = { stemsDirection: optionsOrStemsDirection };
    } else {
      options = optionsOrStemsDirection || {};
    }
    const stemsDir = options.stemsDirection === "down" ? "down" : "up";
    return this.createSVG(grid, stemsDir, options);
  }
  createSVG(grid, stemsDirection, options) {
    const measuresPerLine = 4;
    const baseMeasureWidth = 240;
    const measureHeight = 120;
    const timeSignatureString = `${grid.timeSignature.numerator}/${grid.timeSignature.denominator}`;
    const timeSigFontSize = 18;
    const timeSigAvgCharFactor = 0.53;
    const timeSigWidthEstimate = Math.ceil(timeSignatureString.length * timeSigFontSize * timeSigAvgCharFactor);
    const baseLeftPadding = 10;
    const dynamicLineStartPadding = baseLeftPadding + timeSigWidthEstimate + 4;
    const separatorWidth = 12;
    const innerPaddingPerSegment = 20;
    const headHalfMax = 6;
    const valueMinSpacing = (v) => {
      if (v >= 64) return 16;
      if (v >= 32) return 20;
      if (v >= 16) return 26;
      if (v >= 8) return 24;
      return 20;
    };
    const requiredBeatWidth = (beat) => {
      var _a;
      const noteCount = ((_a = beat == null ? void 0 : beat.notes) == null ? void 0 : _a.length) || 0;
      if (noteCount <= 1) return 28 + 10 + headHalfMax;
      const spacing = Math.max(
        ...beat.notes.map((n) => {
          const base = valueMinSpacing(n.value);
          return n.isRest ? base + 4 : base;
        })
      );
      return 10 + 10 + headHalfMax + (noteCount - 1) * spacing + 8;
    };
    const requiredMeasureWidth = (measure) => {
      const segments = measure.chordSegments || [{ chord: measure.chord, beats: measure.beats }];
      let width2 = 0;
      segments.forEach((seg, idx) => {
        if (idx > 0 && seg.leadingSpace) width2 += separatorWidth;
        const beatsWidth = (seg.beats || []).reduce((acc, b) => acc + requiredBeatWidth(b), 0);
        width2 += beatsWidth + innerPaddingPerSegment;
      });
      return Math.max(baseMeasureWidth, Math.ceil(width2));
    };
    const dynamicMeasureWidths = grid.measures.map((m) => requiredMeasureWidth(m));
    let currentLine = 0;
    let measuresInCurrentLine = 0;
    const measurePositions = [];
    let globalIndex = 0;
    const maxLineWidth = measuresPerLine * baseMeasureWidth;
    let currentLineWidth = 0;
    grid.measures.forEach((measure, mi) => {
      const mWidth = dynamicMeasureWidths[mi];
      if (measuresInCurrentLine > 0 && currentLineWidth + mWidth > maxLineWidth) {
        currentLine++;
        measuresInCurrentLine = 0;
        currentLineWidth = 0;
      }
      const isLineStart = measuresInCurrentLine === 0;
      measure.__isLineStart = isLineStart;
      measurePositions.push({ measure, lineIndex: currentLine, posInLine: measuresInCurrentLine, globalIndex: globalIndex++, width: mWidth });
      measuresInCurrentLine++;
      currentLineWidth += mWidth;
      if (measure.isLineBreak) {
        currentLine++;
        measuresInCurrentLine = 0;
        currentLineWidth = 0;
      }
    });
    const lines = currentLine + 1;
    const linesWidths = new Array(lines).fill(0);
    measurePositions.forEach((p) => {
      linesWidths[p.lineIndex] += p.width;
    });
    const width = Math.max(...linesWidths, baseMeasureWidth) + 60;
    const height = lines * (measureHeight + 20) + 20;
    const svg = document.createElementNS(SVG_NS, "svg");
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", "auto");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    svg.setAttribute("xmlns", SVG_NS);
    const collisionManager = new CollisionManager();
    const tieManager = new TieManager();
    const notePositions = [];
    const bg = document.createElementNS(SVG_NS, "rect");
    bg.setAttribute("x", "0");
    bg.setAttribute("y", "0");
    bg.setAttribute("width", String(width));
    bg.setAttribute("height", String(height));
    bg.setAttribute("fill", "white");
    svg.appendChild(bg);
    const timeSigBaselineY = 40;
    const timeText = this.createText(timeSignatureString, baseLeftPadding, timeSigBaselineY, `${timeSigFontSize}px`, "bold");
    svg.appendChild(timeText);
    svg.__dynamicLineStartPadding = dynamicLineStartPadding;
    collisionManager.registerElement("time-signature", {
      x: baseLeftPadding,
      y: timeSigBaselineY - timeSigFontSize,
      width: timeSigWidthEstimate,
      height: timeSigFontSize + 4
    }, 0, { text: timeSignatureString, widthEstimate: timeSigWidthEstimate });
    let analyzedMeasures = [];
    let level1BeamSet;
    try {
      const parser = new ChordGridParser();
      const analyzer = new MusicAnalyzer();
      analyzedMeasures = grid.measures.map((m) => {
        const segments = (m.chordSegments || [{ chord: m.chord, beats: m.beats }]).map((seg) => {
          const notes = [];
          seg.beats.forEach((beat, beatIndex) => {
            beat.notes.forEach((n) => {
              notes.push({
                value: n.value,
                dotted: n.dotted,
                isRest: n.isRest,
                tieStart: n.tieStart || false,
                tieEnd: n.tieEnd || false,
                tieToVoid: n.tieToVoid || false,
                tieFromVoid: n.tieFromVoid || false,
                beatIndex,
                // Preserve beat index for beam breaking
                tuplet: n.tuplet,
                // Preserve tuplet information
                hasLeadingSpace: n.hasLeadingSpace
                // Preserve spacing flag for tuplet subgroups
              });
            });
          });
          return {
            chord: seg.chord,
            leadingSpace: !!seg.leadingSpace,
            notes
          };
        });
        const parsedMeasure = {
          segments,
          timeSignature: grid.timeSignature,
          barline: m.barline || "|",
          isLineBreak: m.isLineBreak || false,
          source: m.source || ""
        };
        const analyzed = analyzer.analyze(parsedMeasure);
        return analyzed;
      });
      level1BeamSet = /* @__PURE__ */ new Set();
      analyzedMeasures.forEach((am, mi) => {
        var _a;
        (_a = am.beamGroups) == null ? void 0 : _a.forEach((g) => {
          if (g.level === 1 && !g.isPartial && g.notes.length >= 2) {
            g.notes.forEach((r) => {
              level1BeamSet.add(`${mi}:${r.segmentIndex}:${r.noteIndex}`);
            });
          }
        });
      });
    } catch (e) {
      analyzedMeasures = [];
    }
    const lineAccumulated = new Array(lines).fill(dynamicLineStartPadding);
    measurePositions.forEach(({ measure, lineIndex, posInLine, globalIndex: globalIndex2, width: mWidth }) => {
      var _a, _b, _c;
      const x = lineAccumulated[lineIndex];
      const y = lineIndex * (measureHeight + 20) + 20;
      let perMeasureBeamSet;
      if (level1BeamSet) {
        perMeasureBeamSet = /* @__PURE__ */ new Set();
        (_b = (_a = analyzedMeasures[globalIndex2]) == null ? void 0 : _a.beamGroups) == null ? void 0 : _b.forEach((g) => {
          if (g.level === 1 && !g.isPartial && g.notes.length >= 2) {
            g.notes.forEach((r) => {
              const key = `${r.segmentIndex}:${r.noteIndex}`;
              perMeasureBeamSet.add(key);
            });
          }
        });
      }
      const stemsDir = stemsDirection === "down" ? "down" : "up";
      const mr = new MeasureRenderer(measure, x, y, mWidth, perMeasureBeamSet, collisionManager, stemsDir != null ? stemsDir : "up", (_c = options.displayRepeatSymbol) != null ? _c : false);
      mr.drawMeasure(svg, globalIndex2, notePositions, grid);
      if (analyzedMeasures[globalIndex2]) {
        drawAnalyzerBeams(svg, analyzedMeasures[globalIndex2], globalIndex2, notePositions, stemsDir);
      }
      lineAccumulated[lineIndex] += mWidth;
    });
    this.detectAndDrawTies(svg, notePositions, width, tieManager, measurePositions, collisionManager, stemsDirection);
    return svg;
  }
  /**
   * Crée un élément texte SVG avec les propriétés spécifiées.
   * 
   * @param text - Contenu du texte
   * @param x - Position X
   * @param y - Position Y
   * @param size - Taille de la police
   * @param weight - Poids de la police (normal, bold, etc.)
   * @returns Élément SVG text
   */
  createText(text, x, y, size, weight = "normal") {
    const textEl = document.createElementNS(SVG_NS, "text");
    textEl.setAttribute("x", String(x));
    textEl.setAttribute("y", String(y));
    textEl.setAttribute("font-family", "Arial, sans-serif");
    textEl.setAttribute("font-size", size);
    textEl.setAttribute("font-weight", weight);
    textEl.setAttribute("fill", "#000");
    textEl.textContent = text;
    return textEl;
  }
  /**
   * Détecte et dessine les liaisons (ties) entre notes.
   * 
   * Cette méthode gère trois types de liaisons :
   * 1. Liaisons normales entre notes adjacentes
   * 2. Liaisons "to void" (vers une note virtuelle en fin de ligne)
   * 3. Liaisons "from void" (depuis une note virtuelle en début de ligne)
   * 
   * Les liaisons entre lignes sont gérées par le TieManager.
   * 
   * @param svg - Élément SVG parent
   * @param notePositions - Tableau des positions de toutes les notes
   * @param svgWidth - Largeur totale du SVG
   * @param tieManager - Gestionnaire de liaisons entre lignes
   * @param measurePositions - Positions et lignes des mesures (pour détecter les changements de ligne)
   */
  detectAndDrawTies(svg, notePositions, svgWidth, tieManager, measurePositions, collisionManager, stemsDirection) {
    var _a;
    const lineStartPadding = (_a = svg.__dynamicLineStartPadding) != null ? _a : 40;
    const maxLineIndex = Math.max(0, ...measurePositions.map((m) => m.lineIndex));
    const lineOffsets = new Array(maxLineIndex + 1).fill(lineStartPadding);
    const measureXB = {};
    measurePositions.sort((a, b) => a.globalIndex - b.globalIndex).forEach((mp) => {
      const xStart = lineOffsets[mp.lineIndex];
      const xEnd = xStart + mp.width;
      const y = mp.lineIndex * (120 + 20) + 20;
      measureXB[mp.globalIndex] = { xStart, xEnd, y };
      lineOffsets[mp.lineIndex] += mp.width;
    });
    for (let i = 0; i < notePositions.length; i++) {
      const cur = notePositions[i];
      if (cur.tieStart && !cur.tieToVoid) {
        const curMeasurePos = measurePositions.find((mp) => mp.globalIndex === cur.measureIndex);
        if (!curMeasurePos) continue;
        let sameLineTarget = null;
        let crossLineTarget = null;
        for (let j = i + 1; j < notePositions.length; j++) {
          const target = notePositions[j];
          if (!(target.tieEnd || target.tieFromVoid)) continue;
          const targetMeasurePos = measurePositions.find((mp) => mp.globalIndex === target.measureIndex);
          if (!targetMeasurePos) continue;
          if (target.measureIndex === cur.measureIndex) {
            sameLineTarget = target;
            break;
          } else if (targetMeasurePos.lineIndex === curMeasurePos.lineIndex) {
            sameLineTarget = target;
            break;
          } else if (!crossLineTarget) {
            crossLineTarget = target;
          }
        }
        if (!sameLineTarget && crossLineTarget) {
          cur.tieToVoid = true;
          if (!crossLineTarget.tieFromVoid) crossLineTarget.tieFromVoid = true;
          cur.tieStart = false;
        }
      }
    }
    const matched = /* @__PURE__ */ new Set();
    const dotsForCollisions = collisionManager ? collisionManager.getElements().filter((e) => e.type === "dot") : [];
    const fallbackStemsOrientation = stemsDirection != null ? stemsDirection : "down";
    const inferStemsOrientation = (note) => {
      if (note.stemTopY !== void 0 && note.stemBottomY !== void 0) {
        return note.stemTopY <= note.y ? "up" : "down";
      }
      return fallbackStemsOrientation;
    };
    const resolveAnchorY = (note, edge, orientation) => {
      const stemCandidate = orientation === "up" ? note.stemBottomY : note.stemTopY;
      const headEdge = edge === "right" ? note.headRightX : note.headLeftX;
      const horizontalHalf = headEdge !== void 0 ? Math.abs(headEdge - note.x) : 0;
      const baselineOffset = Math.max(3, Math.min(5, horizontalHalf > 0 ? horizontalHalf * 0.6 : 3));
      let anchor = stemCandidate;
      if (anchor === void 0 || (orientation === "up" ? anchor <= note.y : anchor >= note.y)) {
        anchor = note.y + (orientation === "up" ? baselineOffset : -baselineOffset);
      }
      let clearance;
      if (orientation === "up") {
        clearance = edge === "right" ? -1 : 3.5;
      } else {
        clearance = edge === "right" ? 3.5 : -1;
      }
      return anchor + (orientation === "up" ? clearance : -clearance);
    };
    const drawCurve = (startX, startY, endX, endY, isCross, orientation, meta) => {
      const path = document.createElementNS(SVG_NS, "path");
      const dx = Math.abs(endX - startX);
      const baseAmp = Math.min(40, Math.max(8, dx / 6));
      let controlY;
      if (orientation === "up") {
        controlY = Math.max(startY, endY) + (isCross ? baseAmp + 10 : baseAmp);
      } else {
        controlY = Math.min(startY, endY) - (isCross ? baseAmp + 10 : baseAmp);
      }
      if (collisionManager) {
        const minX = Math.min(startX, endX);
        const maxX = Math.max(startX, endX);
        const preliminaryTopY = orientation === "up" ? Math.min(startY, endY) : controlY;
        const preliminaryBottomY = orientation === "up" ? controlY : Math.max(startY, endY);
        const overlappingDot = dotsForCollisions.find((d2) => {
          const db = d2.bbox;
          const horiz = db.x < maxX && db.x + db.width > minX;
          const vert = db.y + db.height >= preliminaryTopY && db.y <= preliminaryBottomY;
          return horiz && vert;
        });
        if (overlappingDot) {
          const adjust = Math.max(6, baseAmp * 0.6);
          controlY += orientation === "up" ? adjust : -adjust;
        }
      }
      const midX = (startX + endX) / 2;
      const d = `M ${startX} ${startY} Q ${midX} ${controlY} ${endX} ${endY}`;
      path.setAttribute("d", d);
      path.setAttribute("stroke", "#000");
      path.setAttribute("stroke-width", "1.5");
      path.setAttribute("fill", "none");
      if (meta == null ? void 0 : meta.half) {
        path.setAttribute("data-half-tie", "1");
      }
      if (meta == null ? void 0 : meta.start) {
        const s = meta.start;
        path.setAttribute("data-start", `${s.measureIndex}:${s.chordIndex}:${s.beatIndex}:${s.noteIndex}`);
      }
      if (meta == null ? void 0 : meta.end) {
        const e = meta.end;
        path.setAttribute("data-end", `${e.measureIndex}:${e.chordIndex}:${e.beatIndex}:${e.noteIndex}`);
      }
      svg.appendChild(path);
      if (collisionManager) {
        const minX = Math.min(startX, endX);
        const maxX = Math.max(startX, endX);
        const topY = Math.min(controlY, startY, endY);
        const bottomY = Math.max(controlY, startY, endY);
        collisionManager.registerElement("tie", { x: minX, y: topY, width: maxX - minX, height: bottomY - topY }, 3, { cross: isCross });
      }
    };
    const drawHalfToMeasureRight = (measureIdx, startX, startY, orientation, startMeta) => {
      const bounds = measureXB[measureIdx];
      const marginX = bounds ? bounds.xEnd - 8 : svgWidth - 16;
      drawCurve(startX, startY, marginX, startY, true, orientation, { start: startMeta, half: true });
      return { x: marginX, y: startY };
    };
    const drawHalfFromMeasureLeft = (measureIdx, endX, endY, orientation, endMeta) => {
      const bounds = measureXB[measureIdx];
      const startX = bounds ? bounds.xStart + 4 : 16;
      drawCurve(startX, endY, endX, endY, true, orientation, { end: endMeta, half: true });
    };
    for (let i = 0; i < notePositions.length; i++) {
      if (matched.has(i)) continue;
      const cur = notePositions[i];
      const orientation = inferStemsOrientation(cur);
      const isDiamond = cur.value === 1 || cur.value === 2;
      let startX;
      if (isDiamond) {
        startX = cur.x;
      } else {
        startX = orientation === "up" ? cur.headLeftX !== void 0 ? cur.headLeftX : cur.x : cur.headRightX !== void 0 ? cur.headRightX : cur.x;
      }
      const startY = resolveAnchorY(cur, orientation === "up" ? "left" : "right", orientation);
      if (cur.tieStart || cur.tieToVoid) {
        if (cur.tieToVoid) {
          const pending = drawHalfToMeasureRight(cur.measureIndex, startX, startY, orientation);
          tieManager.addPendingTie(cur.measureIndex, pending.x, pending.y);
          matched.add(i);
          continue;
        }
        let found = -1;
        for (let j = i + 1; j < notePositions.length; j++) {
          if (matched.has(j)) continue;
          const cand = notePositions[j];
          if (!cand.tieEnd) continue;
          if (cand.measureIndex === cur.measureIndex) {
            found = j;
            break;
          }
        }
        if (found < 0) {
          for (let j = i + 1; j < notePositions.length; j++) {
            if (matched.has(j)) continue;
            const cand = notePositions[j];
            if (cand.tieEnd) {
              found = j;
              break;
            }
          }
        }
        if (found >= 0) {
          const tgt = notePositions[found];
          const targetOrientation = inferStemsOrientation(tgt);
          const isTargetDiamond = tgt.value === 1 || tgt.value === 2;
          let endX;
          if (isTargetDiamond) {
            endX = tgt.x;
          } else {
            endX = targetOrientation === "up" ? tgt.headLeftX !== void 0 ? tgt.headLeftX : tgt.x : tgt.headRightX !== void 0 ? tgt.headRightX : tgt.x;
          }
          const endY = resolveAnchorY(tgt, targetOrientation === "up" ? "left" : "right", targetOrientation);
          drawCurve(startX, startY, endX, endY, cur.measureIndex !== tgt.measureIndex, targetOrientation, {
            start: { measureIndex: cur.measureIndex, chordIndex: cur.chordIndex, beatIndex: cur.beatIndex, noteIndex: cur.noteIndex },
            end: { measureIndex: tgt.measureIndex, chordIndex: tgt.chordIndex, beatIndex: tgt.beatIndex, noteIndex: tgt.noteIndex }
          });
          matched.add(i);
          matched.add(found);
          continue;
        }
        let foundFromVoid = -1;
        for (let j = i + 1; j < notePositions.length; j++) {
          if (matched.has(j)) continue;
          const cand = notePositions[j];
          if (cand.tieFromVoid) {
            foundFromVoid = j;
            break;
          }
        }
        if (foundFromVoid >= 0) {
          const tgt = notePositions[foundFromVoid];
          const curMP = measurePositions.find((mp) => mp.globalIndex === cur.measureIndex);
          const tgtMP = measurePositions.find((mp) => mp.globalIndex === tgt.measureIndex);
          const crossesLine = !!(curMP && tgtMP && curMP.lineIndex !== tgtMP.lineIndex);
          if (crossesLine) {
            const pending = drawHalfToMeasureRight(cur.measureIndex, startX, startY, orientation);
            tieManager.addPendingTie(cur.measureIndex, pending.x, pending.y);
            matched.add(i);
          } else {
            const targetOrientation = inferStemsOrientation(tgt);
            const isTargetDiamond = tgt.value === 1 || tgt.value === 2;
            let endX;
            if (isTargetDiamond) {
              endX = tgt.x;
            } else {
              endX = targetOrientation === "up" ? tgt.headLeftX !== void 0 ? tgt.headLeftX : tgt.x : tgt.headRightX !== void 0 ? tgt.headRightX : tgt.x;
            }
            const endY = resolveAnchorY(tgt, targetOrientation === "up" ? "left" : "right", targetOrientation);
            drawCurve(startX, startY, endX, endY, false, targetOrientation, {
              start: { measureIndex: cur.measureIndex, chordIndex: cur.chordIndex, beatIndex: cur.beatIndex, noteIndex: cur.noteIndex },
              end: { measureIndex: tgt.measureIndex, chordIndex: tgt.chordIndex, beatIndex: tgt.beatIndex, noteIndex: tgt.noteIndex }
            });
            matched.add(i);
            matched.add(foundFromVoid);
          }
          continue;
        }
      }
      if (cur.tieFromVoid && !matched.has(i)) {
        let endX = cur.headLeftX !== void 0 ? cur.headLeftX : cur.x;
        const orientation2 = inferStemsOrientation(cur);
        let endY = resolveAnchorY(cur, "left", orientation2);
        drawHalfFromMeasureLeft(cur.measureIndex, endX, endY, orientation2, { measureIndex: cur.measureIndex, chordIndex: cur.chordIndex, beatIndex: cur.beatIndex, noteIndex: cur.noteIndex });
        matched.add(i);
      }
    }
  }
};

// main.ts
var ChordGridPlugin = class extends import_obsidian.Plugin {
  /**
   * Méthode appelée lors du chargement du plugin.
   * 
   * Enregistre le processeur de blocs de code pour le langage `chordgrid`.
   * Ce processeur :
   * 1. Parse le contenu du bloc avec ChordGridParser
   * 2. Valide la durée des mesures par rapport à la signature temporelle
   * 3. Affiche les erreurs de validation le cas échéant
   * 4. Rend la grille en SVG avec SVGRenderer
   * 
   * En cas d'erreur de parsing, affiche un message d'erreur formaté.
   */
  async onload() {
    console.log("Loading Chord Grid Plugin");
    this.registerMarkdownCodeBlockProcessor(
      "chordgrid",
      (source, el, ctx) => {
        var _a;
        try {
          const parser = new ChordGridParser();
          const result = parser.parse(source);
          const grid = result.grid;
          if (result.errors && result.errors.length > 0) {
            const pre = el.createEl("pre", { cls: "chord-grid-error" });
            pre.setText("Rhythm validation errors:\n" + result.errors.map((e) => e.message).join("\n"));
          }
          const renderer = new SVGRenderer();
          const svg = renderer.render(grid, {
            stemsDirection: result.stemsDirection,
            displayRepeatSymbol: result.displayRepeatSymbol
          });
          el.appendChild(svg);
        } catch (err) {
          const error = err;
          el.createEl("pre", {
            text: `Erreur: ${(_a = error == null ? void 0 : error.message) != null ? _a : String(err)}`,
            cls: "chord-grid-error"
          });
        }
      }
    );
  }
  /**
   * Méthode appelée lors du déchargement du plugin.
   * 
   * Permet de nettoyer les ressources si nécessaire.
   */
  onunload() {
    console.log("Unloading Chord Grid Plugin");
  }
};
