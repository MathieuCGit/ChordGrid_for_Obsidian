/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ChordGridPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/parser/ChordGridParser.ts
var ChordGridParser = class {
  /**
   * Parse une grille d'accords en notation textuelle.
   * 
   * @param input - Chaîne contenant la grille d'accords en notation textuelle
   * @returns Objet ParseResult contenant :
   *   - grid : la structure ChordGrid parsée
   *   - errors : tableau d'erreurs de validation (mesures mal formées)
   *   - measures : tableau de toutes les mesures
   */
  parse(input) {
    const lines = input.trim().split("\n");
    const firstLine = lines[0];
    const timeSignature = this.parseTimeSignature(firstLine);
    const allMeasures = [];
    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
      const line = lines[lineIndex];
      const measures = this.parseLine(line, lineIndex === 0);
      if (measures.length > 0 && lineIndex < lines.length - 1) {
        measures[measures.length - 1].lineBreakAfter = true;
      }
      allMeasures.push(...measures);
    }
    const renderedLines = this.groupIntoLines(allMeasures, 4);
    const grid = {
      timeSignature,
      measures: allMeasures,
      lines: renderedLines
    };
    const errors = [];
    const expectedQuarterNotes = timeSignature.numerator * (4 / timeSignature.denominator);
    for (let mi = 0; mi < allMeasures.length; mi++) {
      const measure = allMeasures[mi];
      let foundQuarterNotes = 0;
      for (const beat of measure.beats) {
        for (const n of beat.notes) {
          if (!n.value) continue;
          const baseWhole = 1 / n.value;
          const dottedMultiplier = n.dotted ? 1.5 : 1;
          const whole = baseWhole * dottedMultiplier;
          foundQuarterNotes += whole * 4;
        }
      }
      const diff = Math.abs(foundQuarterNotes - expectedQuarterNotes);
      if (diff > 1e-6) {
        errors.push({
          measureIndex: mi,
          measureSource: measure.source,
          expectedQuarterNotes,
          foundQuarterNotes,
          message: `Measure ${mi + 1}: expected ${expectedQuarterNotes} quarter-notes, found ${foundQuarterNotes.toFixed(3)} (diff ${diff.toFixed(3)})`
        });
      }
    }
    return { grid, errors, measures: allMeasures };
  }
  parseLine(line, isFirstLine) {
    if (isFirstLine) {
      line = line.replace(/^\d+\/\d+\s*/, "");
    }
    const measures = [];
    const tokens = [];
    const re = /(\|\|:|:?\|\||\|)/g;
    let lastIndex = 0;
    let m;
    const parts = [];
    while ((m = re.exec(line)) !== null) {
      const sep = m[0];
      const text = line.slice(lastIndex, m.index);
      parts.push({ sep: null, text });
      parts.push({ sep, text: "" });
      lastIndex = re.lastIndex;
    }
    const trailing = line.slice(lastIndex);
    if (trailing.length > 0) parts.push({ sep: null, text: trailing });
    let currentText = "";
    for (const p of parts) {
      if (p.sep === null) {
        currentText += p.text || "";
      } else {
        tokens.push({ bar: p.sep, content: currentText });
        currentText = "";
      }
    }
    if (currentText.length > 0 && currentText.trim().length > 0) {
      tokens.push({ bar: "|", content: currentText });
    }
    const measureRe = /^\s*([^\[]+?)?\s*(?:\[([^\]]*)\])?\s*$/;
    const analyzer = new BeamAndTieAnalyzer();
    const segmentRe = /(\s*)([^\[\]\s]+)?\s*\[([^\]]*)\]/g;
    const nonEmptyTokens = tokens.filter((t) => t.content.trim().length > 0);
    for (let ti = 0; ti < nonEmptyTokens.length; ti++) {
      const t = nonEmptyTokens[ti];
      const text = t.content;
      const bar = t.bar;
      const beats = [];
      let firstChord = "";
      let anySource = "";
      let m2;
      const isFirstMeasureOfLine = ti === 0;
      const isLastMeasureOfLine = ti === nonEmptyTokens.length - 1;
      const chordSegments = [];
      while ((m2 = segmentRe.exec(text)) !== null) {
        const leadingSpaceCapture = m2[1] || "";
        const chord = (m2[2] || "").trim();
        const rhythm = (m2[3] || "").trim();
        const sourceText = m2[0];
        if (!firstChord && chord) firstChord = chord;
        anySource += (anySource ? " " : "") + sourceText;
        if (rhythm.length > 0) {
          let hasSignificantSpace = false;
          const chordLetter = /[A-G]/.exec(text);
          if (chordLetter && typeof chordLetter.index === "number") {
            const charBeforeLetter = chordLetter.index > 0 ? text.charAt(chordLetter.index - 1) : null;
            hasSignificantSpace = charBeforeLetter === " " || charBeforeLetter === "	";
            console.log(`D\xE9tection accord:`, {
              letter: chordLetter[0],
              position: chordLetter.index,
              charBefore: charBeforeLetter,
              hasSpace: hasSignificantSpace
            });
          }
          const parsedBeats = analyzer.analyzeRhythmGroup(rhythm, chord, isFirstMeasureOfLine, isLastMeasureOfLine, hasSignificantSpace);
          chordSegments.push({
            chord,
            // utiliser l'accord actuel
            beats: parsedBeats,
            leadingSpace: hasSignificantSpace
          });
          beats.push(...parsedBeats);
        }
      }
      console.log("Parsed chords:", chordSegments.map((s) => s.chord));
      const measure = {
        beats,
        chord: firstChord,
        // garder pour compatibilité
        chordSegments,
        // nouvelle propriété pour tous les accords
        barline: bar,
        lineBreakAfter: false,
        source: anySource || text
      };
      this.reanalyzeCrossSegmentBeams(measure);
      measures.push(measure);
    }
    return measures;
  }
  /**
   * Re-analyze beams across all segments of a measure to properly connect beams
   * when segments don't have leading space (e.g., [8]G[8] should have connected beams).
   * 
   * This method collects all beamable notes (value >= 8, not rests) from all segments,
   * respecting segment boundaries only when leadingSpace=true, and creates unified
   * beam groups that can span multiple chord segments.
   */
  reanalyzeCrossSegmentBeams(measure) {
    if (!measure.chordSegments || measure.chordSegments.length === 0) return;
    const allNotes = [];
    for (let segIdx = 0; segIdx < measure.chordSegments.length; segIdx++) {
      const segment = measure.chordSegments[segIdx];
      const hasLeadingSpace = segment.leadingSpace || false;
      for (let beatIdx = 0; beatIdx < segment.beats.length; beatIdx++) {
        const beat = segment.beats[beatIdx];
        for (let noteIdx = 0; noteIdx < beat.notes.length; noteIdx++) {
          const note = beat.notes[noteIdx];
          const isBeamable = note.value >= 8 && !note.isRest;
          allNotes.push({
            note,
            segmentIndex: segIdx,
            beatIndex: beatIdx,
            noteIndex: noteIdx,
            isBeamable
          });
        }
      }
      if (hasLeadingSpace && segIdx > 0 && allNotes.length > 0) {
        allNotes[allNotes.length - 1].beamBreakAfter = true;
      }
    }
    const beamGroups = [];
    let currentGroup = [];
    for (let i = 0; i < allNotes.length; i++) {
      const item = allNotes[i];
      if (item.isBeamable) {
        currentGroup.push(i);
      } else {
        if (currentGroup.length > 1) {
        }
        currentGroup = [];
      }
      const nextSegmentIndex = i < allNotes.length - 1 ? allNotes[i + 1].segmentIndex : -1;
      const hasBeamBreak = allNotes[i].beamBreakAfter || nextSegmentIndex > item.segmentIndex && nextSegmentIndex < measure.chordSegments.length && measure.chordSegments[nextSegmentIndex].leadingSpace;
      if (hasBeamBreak && currentGroup.length > 0) {
        if (currentGroup.length > 1) {
        }
        currentGroup = [];
      }
    }
    if (currentGroup.length > 1) {
    }
  }
  /**
   * Parse la signature temporelle depuis la première ligne.
   * 
   * @param line - Première ligne contenant la signature temporelle (ex: "4/4 ||: C[4 4 4 4]")
   * @returns Objet TimeSignature avec numérateur et dénominateur
   * @default { numerator: 4, denominator: 4 } si aucune signature n'est trouvée
   */
  parseTimeSignature(line) {
    const m = /^\s*(\d+)\/(\d+)/.exec(line);
    if (m) {
      return {
        numerator: parseInt(m[1], 10),
        denominator: parseInt(m[2], 10)
      };
    }
    return { numerator: 4, denominator: 4 };
  }
  /**
   * Regroupe les mesures en lignes pour le rendu.
   * 
   * @param measures - Tableau de toutes les mesures
   * @param perLine - Nombre de mesures par ligne (généralement 4)
   * @returns Tableau de lignes, chaque ligne contenant un tableau de mesures
   */
  groupIntoLines(measures, perLine) {
    const lines = [];
    for (let i = 0; i < measures.length; i += perLine) {
      lines.push(measures.slice(i, i + perLine));
    }
    return lines;
  }
};
var BeamAndTieAnalyzer = class {
  constructor() {
    __publicField(this, "tieContext");
    // Garder le contexte du dernier groupe de notes pour détecter
    // si deux segments doivent être liés ou séparés
    __publicField(this, "rhythmContext");
    this.tieContext = {
      lastNote: null,
      crossMeasure: false,
      crossLine: false,
      pendingTieToVoid: false
    };
    this.rhythmContext = {
      lastGroupTime: 0,
      lastGroupHasSpace: false,
      lastBeamableNotes: []
    };
  }
  analyzeRhythmGroup(rhythmStr, chord, isFirstMeasureOfLine, isLastMeasureOfLine, hasSignificantSpace = false) {
    var _a, _b, _c;
    const beats = [];
    let currentBeat = [];
    let i = 0;
    while (i < rhythmStr.length) {
      if (rhythmStr[i] === "_") {
        if (i === rhythmStr.length - 1 && isLastMeasureOfLine) {
          this.markTieToVoid(currentBeat);
        } else if (i === 0 && isFirstMeasureOfLine) {
          this.tieContext.pendingTieToVoid = false;
        } else {
          this.markTieStart(currentBeat);
        }
        i++;
        continue;
      }
      if (rhythmStr[i] === " ") {
        if (currentBeat.length > 0) {
          beats.push(this.createBeat(currentBeat));
          currentBeat = [];
        }
        i++;
        continue;
      }
      if (rhythmStr[i] === "-") {
        i++;
        const note2 = this.parseNote(rhythmStr, i);
        note2.isRest = true;
        currentBeat.push(note2);
        i += (_a = note2.length) != null ? _a : 0;
        continue;
      }
      const note = this.parseNote(rhythmStr, i);
      if (i === 0 && isFirstMeasureOfLine && rhythmStr[0] === "_") {
        note.tieFromVoid = true;
      }
      if ((_b = this.tieContext.lastNote) == null ? void 0 : _b.tieStart) {
        note.tieEnd = true;
        this.tieContext.lastNote = null;
      }
      currentBeat.push(note);
      i += (_c = note.length) != null ? _c : 0;
    }
    if (currentBeat.length > 0) {
      beats.push(this.createBeat(currentBeat));
    }
    this.rhythmContext.lastGroupHasSpace = hasSignificantSpace;
    return beats;
  }
  markTieToVoid(notes) {
    if (notes.length > 0) {
      const lastNote = notes[notes.length - 1];
      lastNote.tieStart = true;
      lastNote.tieToVoid = true;
      this.tieContext.pendingTieToVoid = true;
    }
  }
  parseNote(rhythmStr, startIndex) {
    const VALID = ["64", "32", "16", "8", "4", "2", "1"];
    for (const v of VALID) {
      if (rhythmStr.startsWith(v, startIndex)) {
        let len = v.length;
        let dotted = false;
        if (startIndex + len < rhythmStr.length && rhythmStr[startIndex + len] === ".") {
          dotted = true;
          len += 1;
        }
        return {
          value: parseInt(v),
          dotted,
          tieStart: false,
          tieEnd: false,
          tieToVoid: false,
          tieFromVoid: false,
          isRest: false,
          position: startIndex,
          length: len
        };
      }
    }
    return {
      value: 4,
      dotted: false,
      tieStart: false,
      tieEnd: false,
      tieToVoid: false,
      tieFromVoid: false,
      isRest: false,
      position: startIndex,
      length: 1
    };
  }
  markTieStart(notes) {
    if (notes.length === 0) return;
    const last = notes[notes.length - 1];
    last.tieStart = true;
    this.tieContext.lastNote = last;
    this.tieContext.crossMeasure = true;
  }
  createBeat(notes) {
    const beatNotes = notes.map((n) => ({ ...n }));
    const beamGroups = [];
    let hasBeam = false;
    const beamableNotes = beatNotes.filter((n) => n.value >= 8 && !n.isRest);
    if (beamableNotes.length > 0) {
      const hasIncomingTie = beamableNotes[0].tieEnd || beamableNotes[0].tieFromVoid;
      const prevBeamableCount = this.rhythmContext.lastBeamableNotes.length;
      if (!this.rhythmContext.lastGroupHasSpace && (hasIncomingTie || prevBeamableCount > 0)) {
        beamGroups.push({
          startIndex: 0,
          endIndex: beamableNotes.length - 1,
          noteCount: prevBeamableCount + beamableNotes.length
        });
        hasBeam = true;
      } else {
        beamGroups.push({
          startIndex: 0,
          endIndex: beamableNotes.length - 1,
          noteCount: beamableNotes.length
        });
        hasBeam = beamableNotes.length > 1;
      }
    }
    this.rhythmContext.lastBeamableNotes = beamableNotes;
    return {
      notes: beatNotes,
      hasBeam,
      beamGroups
    };
  }
  // ...existing code...
};

// src/renderer/constants.ts
var SVG_NS = "http://www.w3.org/2000/svg";

// src/utils/DebugLogger.ts
var DebugLogger = class {
  // Limite pour éviter trop de logs
  /**
   * Active ou désactive le logging.
   */
  static setEnabled(enabled) {
    this.enabled = enabled;
  }
  /**
   * Initialise le conteneur de logs pour un bloc de code donné.
   */
  static init(parentElement) {
    this.logs = [];
    this.logContainer = parentElement.createEl("details", { cls: "chord-grid-debug" });
    const summary = this.logContainer.createEl("summary");
    summary.setText("\u{1F41B} Debug Logs");
    const logContent = this.logContainer.createEl("pre", {
      cls: "chord-grid-debug-content"
    });
    logContent.style.cssText = `
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
      font-family: 'Consolas', 'Monaco', monospace;
    `;
    return this.logContainer;
  }
  /**
   * Enregistre un message de log.
   */
  static log(message, data) {
    if (!this.enabled) return;
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString();
    const logMessage = data ? `[${timestamp}] ${message}: ${JSON.stringify(data, null, 2)}` : `[${timestamp}] ${message}`;
    this.logs.push(logMessage);
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }
    console.log(`[ChordGrid] ${message}`, data);
    this.render();
  }
  /**
   * Enregistre un message d'erreur.
   */
  static error(message, error) {
    if (!this.enabled) return;
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString();
    const errorMessage = error ? `[${timestamp}] \u274C ERROR: ${message}: ${error.message || JSON.stringify(error)}` : `[${timestamp}] \u274C ERROR: ${message}`;
    this.logs.push(errorMessage);
    console.error(`[ChordGrid] ${message}`, error);
    this.render();
  }
  /**
   * Enregistre un message d'avertissement.
   */
  static warn(message, data) {
    if (!this.enabled) return;
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString();
    const warnMessage = data ? `[${timestamp}] \u26A0\uFE0F WARN: ${message}: ${JSON.stringify(data, null, 2)}` : `[${timestamp}] \u26A0\uFE0F WARN: ${message}`;
    this.logs.push(warnMessage);
    console.warn(`[ChordGrid] ${message}`, data);
    this.render();
  }
  /**
   * Met à jour l'affichage des logs.
   */
  static render() {
    if (!this.logContainer) return;
    const logContent = this.logContainer.querySelector(".chord-grid-debug-content");
    if (logContent) {
      logContent.textContent = this.logs.join("\n");
      logContent.scrollTop = logContent.scrollHeight;
    }
  }
  /**
   * Efface tous les logs.
   */
  static clear() {
    this.logs = [];
    this.render();
  }
};
__publicField(DebugLogger, "enabled", true);
__publicField(DebugLogger, "logContainer", null);
__publicField(DebugLogger, "logs", []);
__publicField(DebugLogger, "maxLogs", 50);

// src/renderer/MeasureRenderer.ts
var MeasureRenderer = class {
  /**
   * Constructeur du renderer de mesure.
   * 
   * @param measure - Mesure à rendre
   * @param x - Position X de départ de la mesure dans le SVG
   * @param y - Position Y de départ de la mesure dans le SVG
   * @param width - Largeur allouée à la mesure
   */
  constructor(measure, x, y, width) {
    this.measure = measure;
    this.x = x;
    this.y = y;
    this.width = width;
  }
  /**
   * Dessine la mesure complète dans le SVG.
   * 
   * Cette méthode orchestre le rendu de tous les éléments de la mesure :
   * 1. Barres de mesure (gauche avec éventuelle reprise)
   * 2. Ligne de portée
   * 3. Segments d'accords avec leurs beats
   * 4. Notes et silences avec ligatures
   * 5. Barre de mesure de fin (avec éventuelle reprise ou double barre)
   * 
   * @param svg - Élément SVG parent
   * @param measureIndex - Index de la mesure dans la grille (pour numérotation)
   * @param notePositions - Tableau collectant les positions de toutes les notes (pour liaisons)
   * @param grid - Grille complète (pour contexte de signature temporelle, etc.)
   */
  drawMeasure(svg, measureIndex, notePositions, grid) {
    const leftBarX = this.x;
    const rightBarX = this.x + this.width - 2;
    if (measureIndex === 0) {
      this.drawBar(svg, leftBarX, this.y, 120);
    } else if (this.measure.isRepeatStart) {
      this.drawBarWithRepeat(svg, leftBarX, this.y, 120, true);
    }
    const staffLineY = this.y + 80;
    const staffLine = document.createElementNS(SVG_NS, "line");
    staffLine.setAttribute("x1", (this.x + 10).toString());
    staffLine.setAttribute("y1", staffLineY.toString());
    staffLine.setAttribute("x2", (this.x + this.width - 10).toString());
    staffLine.setAttribute("y2", staffLineY.toString());
    staffLine.setAttribute("stroke", "#000");
    staffLine.setAttribute("stroke-width", "1");
    svg.appendChild(staffLine);
    const segments = this.measure.chordSegments || [{ chord: this.measure.chord, beats: this.measure.beats }];
    const totalBeats = segments.reduce((s, seg) => s + (seg.beats ? seg.beats.length : 0), 0) || 1;
    const separatorWidth = 12;
    const separatorsCount = segments.reduce((cnt, seg, idx) => cnt + (idx > 0 && seg.leadingSpace ? 1 : 0), 0);
    const innerPaddingPerSegment = 20;
    const totalInnerPadding = innerPaddingPerSegment * segments.length;
    const totalSeparatorPixels = separatorsCount * separatorWidth;
    const availableForBeatCells = Math.max(0, this.width - totalInnerPadding - totalSeparatorPixels);
    const beatCellWidth = availableForBeatCells / totalBeats;
    let currentX = this.x;
    for (let segmentIndex = 0; segmentIndex < segments.length; segmentIndex++) {
      const segment = segments[segmentIndex];
      if (segmentIndex > 0 && segment.leadingSpace) {
        currentX += separatorWidth;
      }
      const segBeatCount = segment.beats.length || 1;
      const segmentWidth = segBeatCount * beatCellWidth + innerPaddingPerSegment;
      const segmentX = currentX + 10;
      const beatsWidth = segmentWidth - innerPaddingPerSegment;
      const beatWidth = beatsWidth / segBeatCount;
      segment.beats.forEach((beat, beatIndex) => {
        const beatX = segmentX + beatIndex * beatWidth;
        const firstNoteX = this.drawRhythm(svg, beat, beatX, staffLineY, beatWidth, measureIndex, segmentIndex, beatIndex, notePositions);
        if (firstNoteX !== null && beatIndex === 0 && segment.chord) {
          const chordText = this.createText(segment.chord, firstNoteX, this.y + 40, "22px", "bold");
          chordText.setAttribute("text-anchor", "middle");
          chordText.setAttribute("font-family", "Arial, sans-serif");
          svg.appendChild(chordText);
        }
      });
      currentX += segmentWidth;
    }
    if (this.measure.isRepeatEnd) {
      this.drawBarWithRepeat(svg, rightBarX, this.y, 120, false);
    } else if (this.measure.barline || measureIndex === grid.measures.length - 1) {
      this.drawBar(svg, rightBarX, this.y, 120);
    }
  }
  drawRhythm(svg, beat, x, staffLineY, width, measureIndex, chordIndex, beatIndex, notePositions) {
    const beats = [beat];
    const beatWidth = width;
    let currentX = x;
    let firstNoteX = null;
    const first = this.drawBeat(svg, beat, currentX, staffLineY, beatWidth, measureIndex, chordIndex, beatIndex, notePositions);
    if (first !== null) firstNoteX = first;
    return firstNoteX;
  }
  drawBeat(svg, beat, x, staffLineY, width, measureIndex, chordIndex, beatIndex, notePositions) {
    if (!beat || beat.notes.length === 0) return null;
    DebugLogger.log(`\u{1F3BC} Drawing beat ${beatIndex}`, {
      measureIndex,
      chordIndex,
      beatIndex,
      notesCount: beat.notes.length,
      notes: beat.notes.map((n) => ({ value: n.value, isRest: n.isRest })),
      hasBeam: beat.hasBeam,
      beamGroups: beat.beamGroups
    });
    const hasBeamableNotes = beat.notes.some((n) => n.value >= 8 || n.tieStart || n.tieEnd || n.tieToVoid || n.tieFromVoid);
    DebugLogger.log(`Beam detection`, {
      hasBeamableNotes,
      multipleNotes: beat.notes.length > 1,
      willDrawGroup: hasBeamableNotes && beat.notes.length > 1
    });
    if (hasBeamableNotes && beat.notes.length > 1) {
      DebugLogger.log(`\u2705 Drawing note group with beams`);
      const firstNoteX = this.drawNoteGroup(svg, beat.notes, x + 10, staffLineY, width);
      const noteCount = beat.notes.length;
      const hasSmallNotes = beat.notes.some((nv) => nv.value >= 32);
      const noteSpacing = noteCount > 0 ? width / noteCount * (hasSmallNotes ? 1.2 : 1) : width;
      beat.notes.forEach((nv, noteIndex) => {
        const noteX = x + 10 + noteIndex * noteSpacing + noteSpacing / 2;
        let headLeftX;
        let headRightX;
        if (nv.value === 1 || nv.value === 2) {
          const diamondSize = 6;
          headLeftX = noteX - diamondSize;
          headRightX = noteX + diamondSize;
        } else {
          const slashHalf = 10 / 2;
          headLeftX = noteX - slashHalf;
          headRightX = noteX + slashHalf;
        }
        const hasStem = nv.value >= 2;
        const stemTopY = hasStem ? staffLineY + 5 : void 0;
        const stemBottomY = hasStem ? staffLineY + 30 : void 0;
        notePositions.push({
          x: noteX,
          y: staffLineY,
          headLeftX,
          headRightX,
          measureIndex,
          chordIndex,
          beatIndex,
          noteIndex,
          tieStart: !!nv.tieStart,
          tieEnd: !!nv.tieEnd,
          tieToVoid: !!nv.tieToVoid,
          tieFromVoid: !!nv.tieFromVoid,
          globalTimeIndex: measureIndex * 1e6 + chordIndex * 1e4 + beatIndex * 100 + noteIndex,
          stemTopY,
          stemBottomY
        });
      });
      return firstNoteX;
    } else {
      const nv = beat.notes[0];
      const noteX = this.drawSingleNote(svg, nv, x + 10, staffLineY, width);
      let headLeftX;
      let headRightX;
      if (nv.value === 1 || nv.value === 2) {
        const diamondSize = 6;
        headLeftX = noteX - diamondSize;
        headRightX = noteX + diamondSize;
      } else {
        const slashHalf = 10 / 2;
        headLeftX = noteX - slashHalf;
        headRightX = noteX + slashHalf;
      }
      const hasStem = nv.value >= 2;
      const stemTopY = hasStem ? staffLineY + 5 : void 0;
      const stemBottomY = hasStem ? staffLineY + 30 : void 0;
      notePositions.push({
        x: noteX,
        y: staffLineY,
        headLeftX,
        headRightX,
        measureIndex,
        chordIndex,
        beatIndex,
        noteIndex: 0,
        tieStart: !!nv.tieStart,
        tieEnd: !!nv.tieEnd,
        tieToVoid: !!nv.tieToVoid,
        tieFromVoid: !!nv.tieFromVoid,
        globalTimeIndex: measureIndex * 1e6 + chordIndex * 1e4 + beatIndex * 100,
        stemTopY,
        stemBottomY
      });
      return noteX;
    }
  }
  drawSingleNote(svg, nv, x, staffLineY, width) {
    const centerX = x;
    if (nv.value === 1) {
      this.drawDiamondNoteHead(svg, centerX, staffLineY, true);
    } else if (nv.value === 2) {
      this.drawDiamondNoteHead(svg, centerX, staffLineY, true);
      this.drawStem(svg, centerX, staffLineY, 25);
    } else {
      this.drawSlash(svg, centerX, staffLineY);
      this.drawStem(svg, centerX, staffLineY, 25);
      if (nv.value === 8) this.drawFlag(svg, centerX, staffLineY, 1);
      else if (nv.value === 16) this.drawFlag(svg, centerX, staffLineY, 2);
      else if (nv.value === 32) this.drawFlag(svg, centerX, staffLineY, 3);
      else if (nv.value === 64) this.drawFlag(svg, centerX, staffLineY, 4);
    }
    if (nv.dotted) {
      const dot = document.createElementNS(SVG_NS, "circle");
      dot.setAttribute("cx", (centerX + 8).toString());
      dot.setAttribute("cy", staffLineY.toString());
      dot.setAttribute("r", "2");
      dot.setAttribute("fill", "#000");
      svg.appendChild(dot);
    }
    return centerX;
  }
  drawDiamondNoteHead(svg, x, y, hollow) {
    const diamondSize = 6;
    const diamond = document.createElementNS(SVG_NS, "polygon");
    const points = [[x, y - diamondSize], [x + diamondSize, y], [x, y + diamondSize], [x - diamondSize, y]];
    diamond.setAttribute("points", points.map((p) => `${p[0]},${p[1]}`).join(" "));
    diamond.setAttribute("fill", hollow ? "white" : "black");
    diamond.setAttribute("stroke", "#000");
    diamond.setAttribute("stroke-width", "1");
    svg.appendChild(diamond);
  }
  drawNoteGroup(svg, notesValues, x, staffLineY, width) {
    const noteCount = notesValues.length;
    if (noteCount === 0) return null;
    DebugLogger.log("\u{1F3A8} drawNoteGroup called", {
      noteCount,
      notes: notesValues.map((n) => ({ value: n.value, dotted: n.dotted, isRest: n.isRest })),
      x,
      staffLineY,
      width
    });
    const hasSmallNotes = notesValues.some((nv) => nv.value >= 32);
    const noteSpacing = noteCount > 0 ? width / noteCount * (hasSmallNotes ? 1.2 : 1) : width;
    const stemHeight = 25;
    if (noteCount === 1 && notesValues[0].value >= 8) {
      const centerX = x + noteSpacing / 2;
      this.drawSlash(svg, centerX, staffLineY);
      const stem = this.drawStem(svg, centerX, staffLineY, stemHeight);
      const value = notesValues[0].value;
      this.drawFlag(svg, centerX, staffLineY, value === 8 ? 1 : value === 16 ? 2 : value === 32 ? 3 : value === 64 ? 4 : 0);
      return centerX;
    }
    const notes = [];
    for (let i = 0; i < noteCount; i++) {
      const nv = notesValues[i];
      const centerX = x + i * noteSpacing + noteSpacing / 2;
      if (nv.value === 1) {
        this.drawDiamondNoteHead(svg, centerX, staffLineY, true);
        notes.push({ nv, beamCount: 0, centerX });
      } else if (nv.value === 2) {
        this.drawDiamondNoteHead(svg, centerX, staffLineY, true);
        const stemInfo = this.drawStem(svg, centerX, staffLineY, stemHeight);
        notes.push({ nv, beamCount: 0, centerX, stemX: stemInfo.x, stemTopY: stemInfo.topY, stemBottomY: stemInfo.bottomY });
      } else {
        this.drawSlash(svg, centerX, staffLineY);
        const stemInfo = this.drawStem(svg, centerX, staffLineY, stemHeight);
        const prevNote = i > 0 ? notesValues[i - 1] : null;
        const nextNote = i < notesValues.length - 1 ? notesValues[i + 1] : null;
        const needsFlag = nv.value >= 8 && (!prevNote || prevNote.value < 8) && (!nextNote || nextNote.value < 8);
        if (needsFlag) {
          if (nv.value === 8) this.drawFlag(svg, centerX, staffLineY, 1);
          else if (nv.value === 16) this.drawFlag(svg, centerX, staffLineY, 2);
          else if (nv.value === 32) this.drawFlag(svg, centerX, staffLineY, 3);
          else if (nv.value === 64) this.drawFlag(svg, centerX, staffLineY, 4);
        }
        const beamCount = nv.value === 8 ? 1 : nv.value === 16 ? 2 : nv.value === 32 ? 3 : nv.value === 64 ? 4 : 0;
        notes.push({ nv, beamCount, centerX, stemX: stemInfo.x, stemTopY: stemInfo.topY, stemBottomY: stemInfo.bottomY });
      }
      if (nv.dotted) {
        const dot = document.createElementNS(SVG_NS, "circle");
        dot.setAttribute("cx", (centerX + 8).toString());
        dot.setAttribute("cy", staffLineY.toString());
        dot.setAttribute("r", "2");
        dot.setAttribute("fill", "#000");
        svg.appendChild(dot);
      }
    }
    const beamedNotes = notes.filter((n) => n.beamCount > 0);
    DebugLogger.log("\u{1F3B5} Notes prepared for beaming", {
      totalNotes: notes.length,
      beamedNotesCount: beamedNotes.length,
      beamedNotes: beamedNotes.map((n) => ({
        value: n.nv.value,
        beamCount: n.beamCount,
        centerX: n.centerX,
        stemX: n.stemX,
        stemBottomY: n.stemBottomY
      }))
    });
    if (beamedNotes.length === 0) return notes.length ? notes[0].centerX : null;
    const maxBeamCount = Math.max(...beamedNotes.map((n) => n.beamCount));
    if (maxBeamCount === 0) return notes.length ? notes[0].centerX : null;
    DebugLogger.log("\u{1F528} Starting beam drawing", { maxBeamCount });
    const beamGap = 5;
    const validStemBottoms = beamedNotes.map((n) => n.stemBottomY).filter((y) => y !== void 0);
    const baseStemBottom = validStemBottoms.length > 0 ? Math.min(...validStemBottoms) : staffLineY + 30;
    DebugLogger.log("Beam baseline calculated", { baseStemBottom, validStemBottoms });
    for (let level = 1; level <= maxBeamCount; level++) {
      DebugLogger.log(`Drawing beam level ${level}`);
      let segStartIndex = null;
      for (let i = 0; i <= beamedNotes.length; i++) {
        const n = i < beamedNotes.length ? beamedNotes[i] : null;
        const active = n ? n.beamCount >= level : false;
        if (active && segStartIndex === null) {
          segStartIndex = i;
        } else if (!active && segStartIndex !== null) {
          const segEnd = i - 1;
          const beamY = baseStemBottom - (level - 1) * beamGap;
          const startX = beamedNotes[segStartIndex].stemX;
          const endX = beamedNotes[segEnd].stemX;
          if (segStartIndex === segEnd) {
            const beamletLength = 8;
            const currentNote = beamedNotes[segStartIndex].nv;
            const prevNote = segStartIndex > 0 ? beamedNotes[segStartIndex - 1].nv : null;
            const nextNote = segStartIndex < beamedNotes.length - 1 ? beamedNotes[segStartIndex + 1].nv : null;
            let beamletEndX;
            let direction;
            if (prevNote && prevNote.dotted) {
              beamletEndX = startX - beamletLength;
              direction = "left (after dotted note)";
            } else if (nextNote && nextNote.dotted) {
              beamletEndX = startX + beamletLength;
              direction = "right (before dotted note)";
            } else {
              const groupCenter = (beamedNotes.length - 1) / 2;
              const isInFirstHalf = segStartIndex < groupCenter;
              if (isInFirstHalf) {
                beamletEndX = startX + beamletLength;
                direction = "right (first half)";
              } else {
                beamletEndX = startX - beamletLength;
                direction = "left (second half)";
              }
            }
            DebugLogger.log(`\u270F\uFE0F Drawing beamlet (partial beam)`, {
              level,
              from: { x: startX, y: beamY },
              to: { x: beamletEndX, y: beamY },
              noteIndex: segStartIndex,
              direction,
              prevDotted: prevNote == null ? void 0 : prevNote.dotted,
              nextDotted: nextNote == null ? void 0 : nextNote.dotted
            });
            const beamlet = document.createElementNS(SVG_NS, "line");
            beamlet.setAttribute("x1", startX.toString());
            beamlet.setAttribute("y1", beamY.toString());
            beamlet.setAttribute("x2", beamletEndX.toString());
            beamlet.setAttribute("y2", beamY.toString());
            beamlet.setAttribute("stroke", "#000");
            beamlet.setAttribute("stroke-width", "2");
            svg.appendChild(beamlet);
          } else {
            DebugLogger.log(`\u270F\uFE0F Drawing beam segment`, {
              level,
              from: { x: startX, y: beamY },
              to: { x: endX, y: beamY },
              segStartIndex,
              segEnd
            });
            const beam = document.createElementNS(SVG_NS, "line");
            beam.setAttribute("x1", startX.toString());
            beam.setAttribute("y1", beamY.toString());
            beam.setAttribute("x2", endX.toString());
            beam.setAttribute("y2", beamY.toString());
            beam.setAttribute("stroke", "#000");
            beam.setAttribute("stroke-width", "2");
            svg.appendChild(beam);
          }
          segStartIndex = null;
        }
      }
    }
    return notes.length ? notes[0].centerX : null;
  }
  drawSlash(svg, x, y) {
    const slashLength = 10;
    const slash = document.createElementNS(SVG_NS, "line");
    slash.setAttribute("x1", (x + slashLength / 2).toString());
    slash.setAttribute("y1", (y - slashLength / 2).toString());
    slash.setAttribute("x2", (x - slashLength / 2).toString());
    slash.setAttribute("y2", (y + slashLength / 2).toString());
    slash.setAttribute("stroke", "#000");
    slash.setAttribute("stroke-width", "3");
    svg.appendChild(slash);
  }
  drawStem(svg, x, y, height) {
    const slashLength = 10;
    const stemStartX = x - slashLength / 2 + 2;
    const stemStartY = y + slashLength / 2;
    const stem = document.createElementNS(SVG_NS, "line");
    stem.setAttribute("x1", stemStartX.toString());
    stem.setAttribute("y1", stemStartY.toString());
    stem.setAttribute("x2", stemStartX.toString());
    stem.setAttribute("y2", (stemStartY + height).toString());
    stem.setAttribute("stroke", "#000");
    stem.setAttribute("stroke-width", "2");
    svg.appendChild(stem);
    return { x: stemStartX, topY: stemStartY, bottomY: stemStartY + height };
  }
  drawFlag(svg, x, staffLineY, count) {
    const slashLength = 10;
    const stemStartX = x - slashLength / 2 + 2;
    const stemBottomY = staffLineY + slashLength / 2 + 25;
    for (let i = 0; i < count; i++) {
      const flag = document.createElementNS(SVG_NS, "path");
      const flagY = stemBottomY - i * 10;
      flag.setAttribute("d", `M ${stemStartX} ${flagY} Q ${stemStartX - 10} ${flagY - 5} ${stemStartX - 8} ${flagY - 12}`);
      flag.setAttribute("stroke", "#000");
      flag.setAttribute("stroke-width", "2");
      flag.setAttribute("fill", "none");
      svg.appendChild(flag);
    }
  }
  drawBar(svg, x, y, height) {
    const line = document.createElementNS(SVG_NS, "line");
    line.setAttribute("x1", x.toString());
    line.setAttribute("y1", y.toString());
    line.setAttribute("x2", x.toString());
    line.setAttribute("y2", (y + height).toString());
    line.setAttribute("stroke", "#000");
    line.setAttribute("stroke-width", "1.5");
    svg.appendChild(line);
  }
  drawBarWithRepeat(svg, x, y, height, isStart) {
    this.drawDoubleBar(svg, x, y, height);
    const dotOffset = isStart ? 12 : -12;
    const dot1Y = y + height * 0.35;
    const dot2Y = y + height * 0.65;
    [dot1Y, dot2Y].forEach((dotY) => {
      const circle = document.createElementNS(SVG_NS, "circle");
      circle.setAttribute("cx", (x + dotOffset).toString());
      circle.setAttribute("cy", dotY.toString());
      circle.setAttribute("r", "2");
      circle.setAttribute("fill", "#000");
      svg.appendChild(circle);
    });
  }
  drawDoubleBar(svg, x, y, height) {
    const bar1 = document.createElementNS(SVG_NS, "line");
    bar1.setAttribute("x1", x.toString());
    bar1.setAttribute("y1", y.toString());
    bar1.setAttribute("x2", x.toString());
    bar1.setAttribute("y2", (y + height).toString());
    bar1.setAttribute("stroke", "#000");
    bar1.setAttribute("stroke-width", "1.5");
    svg.appendChild(bar1);
    const bar2 = document.createElementNS(SVG_NS, "line");
    bar2.setAttribute("x1", (x + 6).toString());
    bar2.setAttribute("y1", y.toString());
    bar2.setAttribute("x2", (x + 6).toString());
    bar2.setAttribute("y2", (y + height).toString());
    bar2.setAttribute("stroke", "#000");
    bar2.setAttribute("stroke-width", "1.5");
    svg.appendChild(bar2);
  }
  createText(text, x, y, size, weight = "normal") {
    const textEl = document.createElementNS(SVG_NS, "text");
    textEl.setAttribute("x", x.toString());
    textEl.setAttribute("y", y.toString());
    textEl.setAttribute("font-family", "Arial, sans-serif");
    textEl.setAttribute("font-size", size);
    textEl.setAttribute("font-weight", weight);
    textEl.setAttribute("fill", "#000");
    textEl.textContent = text;
    return textEl;
  }
};

// src/utils/TieManager.ts
var TieManager = class {
  constructor() {
    // pending ties saved when a tie continues beyond the rendered area (e.g. line break)
    __publicField(this, "pending", []);
  }
  /**
   * Ajoute une liaison en attente de résolution.
   * 
   * Utilisé lorsqu'une note se termine par une liaison "to void" en fin de ligne.
   * 
   * @param measureIndex - Index de la mesure contenant la note de départ
   * @param x - Position X de la fin de la liaison
   * @param y - Position Y de la fin de la liaison
   */
  addPendingTie(measureIndex, x, y) {
    DebugLogger.log("\u{1F4CC} Adding pending tie", { measureIndex, x, y });
    this.pending.push({ measureIndex, x, y });
    DebugLogger.log("Current pending ties", { count: this.pending.length, pending: this.pending });
  }
  /**
   * Tente de résoudre une liaison en attente pour une note commençant par "from void".
   * 
   * Recherche une liaison en attente dont l'index de mesure est strictement inférieur
   * à celui donné (car la liaison vient d'une mesure précédente).
   * 
   * @param measureIndex - Index de la mesure contenant la note d'arrivée
   * @returns La liaison en attente (et la retire de la liste) ou null si aucune
   */
  resolvePendingFor(measureIndex) {
    DebugLogger.log("\u{1F50D} Resolving pending tie for measure", { measureIndex, availablePending: this.pending });
    for (let i = 0; i < this.pending.length; i++) {
      if (this.pending[i].measureIndex < measureIndex) {
        const p = this.pending.splice(i, 1)[0];
        DebugLogger.log("\u2705 Resolved pending tie", { resolved: p, remaining: this.pending.length });
        return p;
      }
    }
    DebugLogger.warn("No pending tie found for measure", { measureIndex });
    return null;
  }
  /**
   * Efface toutes les liaisons en attente.
   * 
   * Utilisé pour réinitialiser le gestionnaire entre différents rendus.
   */
  clearPending() {
    this.pending = [];
  }
};

// src/renderer/SVGRenderer.ts
var SVGRenderer = class {
  /**
   * Rend une grille d'accords en élément SVG.
   * 
   * @param grid - Structure ChordGrid contenant les mesures à rendre
   * @returns Élément SVG prêt à être inséré dans le DOM
   */
  render(grid) {
    return this.createSVG(grid);
  }
  createSVG(grid) {
    const measuresPerLine = 4;
    const measureWidth = 200;
    const measureHeight = 120;
    DebugLogger.log("\u{1F4D0} Creating SVG layout", {
      measuresPerLine,
      measureWidth,
      measureHeight
    });
    let currentLine = 0;
    let measuresInCurrentLine = 0;
    const measurePositions = [];
    let globalIndex = 0;
    grid.measures.forEach((measure) => {
      if (measure.isLineBreak) {
        DebugLogger.log("\u21B5 Line break detected");
        currentLine++;
        measuresInCurrentLine = 0;
        return;
      }
      if (measuresInCurrentLine >= measuresPerLine) {
        DebugLogger.log(`\u21B5 Auto line break (${measuresInCurrentLine} measures)`);
        currentLine++;
        measuresInCurrentLine = 0;
      }
      measurePositions.push({ measure, lineIndex: currentLine, posInLine: measuresInCurrentLine, globalIndex: globalIndex++ });
      measuresInCurrentLine++;
    });
    DebugLogger.log("\u{1F4CA} Layout calculated", {
      totalLines: currentLine + 1,
      totalMeasures: measurePositions.length
    });
    const lines = currentLine + 1;
    const width = measuresPerLine * measureWidth + 60;
    const height = lines * (measureHeight + 20) + 20;
    const svg = document.createElementNS(SVG_NS, "svg");
    svg.setAttribute("width", String(width));
    svg.setAttribute("height", String(height));
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    svg.setAttribute("xmlns", SVG_NS);
    const bg = document.createElementNS(SVG_NS, "rect");
    bg.setAttribute("x", "0");
    bg.setAttribute("y", "0");
    bg.setAttribute("width", String(width));
    bg.setAttribute("height", String(height));
    bg.setAttribute("fill", "white");
    svg.appendChild(bg);
    const timeSig = `${grid.timeSignature.numerator}/${grid.timeSignature.denominator}`;
    const timeText = this.createText(timeSig, 10, 40, "18px", "bold");
    svg.appendChild(timeText);
    const notePositions = [];
    const tieManager = new TieManager();
    DebugLogger.log("\u{1F3BC} Rendering measures");
    measurePositions.forEach(({ measure, lineIndex, posInLine, globalIndex: globalIndex2 }) => {
      const x = posInLine * measureWidth + 40;
      const y = lineIndex * (measureHeight + 20) + 20;
      const mr = new MeasureRenderer(measure, x, y, measureWidth);
      mr.drawMeasure(svg, globalIndex2, notePositions, grid);
    });
    DebugLogger.log("\u{1F3B5} Note positions collected", { count: notePositions.length });
    this.detectAndDrawTies(svg, notePositions, width, tieManager);
    return svg;
  }
  /**
   * Crée un élément texte SVG avec les propriétés spécifiées.
   * 
   * @param text - Contenu du texte
   * @param x - Position X
   * @param y - Position Y
   * @param size - Taille de la police
   * @param weight - Poids de la police (normal, bold, etc.)
   * @returns Élément SVG text
   */
  createText(text, x, y, size, weight = "normal") {
    const textEl = document.createElementNS(SVG_NS, "text");
    textEl.setAttribute("x", String(x));
    textEl.setAttribute("y", String(y));
    textEl.setAttribute("font-family", "Arial, sans-serif");
    textEl.setAttribute("font-size", size);
    textEl.setAttribute("font-weight", weight);
    textEl.setAttribute("fill", "#000");
    textEl.textContent = text;
    return textEl;
  }
  /**
   * Détecte et dessine les liaisons (ties) entre notes.
   * 
   * Cette méthode gère trois types de liaisons :
   * 1. Liaisons normales entre notes adjacentes
   * 2. Liaisons "to void" (vers une note virtuelle en fin de ligne)
   * 3. Liaisons "from void" (depuis une note virtuelle en début de ligne)
   * 
   * Les liaisons entre lignes sont gérées par le TieManager.
   * 
   * @param svg - Élément SVG parent
   * @param notePositions - Tableau des positions de toutes les notes
   * @param svgWidth - Largeur totale du SVG
   * @param tieManager - Gestionnaire de liaisons entre lignes
   */
  detectAndDrawTies(svg, notePositions, svgWidth, tieManager) {
    DebugLogger.log("\u{1F517} Starting tie detection and drawing");
    const matched = /* @__PURE__ */ new Set();
    const tieNotes = notePositions.filter((n) => n.tieStart || n.tieEnd || n.tieToVoid || n.tieFromVoid);
    DebugLogger.log("Notes with tie markers", {
      count: tieNotes.length,
      details: tieNotes.map((n, idx) => ({
        index: notePositions.indexOf(n),
        measure: n.measureIndex,
        chord: n.chordIndex,
        beat: n.beatIndex,
        note: n.noteIndex,
        tieStart: n.tieStart,
        tieEnd: n.tieEnd,
        tieToVoid: n.tieToVoid,
        tieFromVoid: n.tieFromVoid,
        position: { x: n.x, y: n.y }
      }))
    });
    const drawCurve = (startX, startY, endX, endY, isCross) => {
      DebugLogger.log("Drawing tie curve", {
        from: { x: startX, y: startY },
        to: { x: endX, y: endY },
        crossMeasure: isCross
      });
      const path = document.createElementNS(SVG_NS, "path");
      const dx = Math.abs(endX - startX);
      const baseAmp = Math.min(40, Math.max(8, dx / 6));
      const controlY = Math.min(startY, endY) - (isCross ? baseAmp + 10 : baseAmp);
      const midX = (startX + endX) / 2;
      const d = `M ${startX} ${startY} Q ${midX} ${controlY} ${endX} ${endY}`;
      path.setAttribute("d", d);
      path.setAttribute("stroke", "#000");
      path.setAttribute("stroke-width", "1.5");
      path.setAttribute("fill", "none");
      svg.appendChild(path);
    };
    const drawHalfToMargin = (startX, startY, svgW) => {
      const marginX = svgW - 16;
      DebugLogger.log("Drawing half-tie to margin (tieToVoid)", {
        from: { x: startX, y: startY },
        toMargin: marginX
      });
      drawCurve(startX, startY, marginX, startY, true);
      return { x: marginX, y: startY };
    };
    DebugLogger.log("\u{1F50D} Primary pass: matching tieStart -> tieEnd");
    for (let i = 0; i < notePositions.length; i++) {
      if (matched.has(i)) continue;
      const cur = notePositions[i];
      const startX = cur.headRightX !== void 0 ? cur.headRightX : cur.x;
      let startY;
      if (cur.headRightX !== void 0) {
        const half = Math.abs(cur.headRightX - cur.x);
        startY = half >= 6 ? cur.y : cur.y - half;
      } else {
        startY = cur.y - 8;
      }
      if (cur.tieStart) {
        DebugLogger.log(`Found tieStart at index ${i}`, {
          measure: cur.measureIndex,
          chord: cur.chordIndex,
          beat: cur.beatIndex
        });
        let found = -1;
        for (let j = i + 1; j < notePositions.length; j++) {
          if (matched.has(j)) continue;
          const cand = notePositions[j];
          if (cand.tieEnd) {
            found = j;
            break;
          }
        }
        if (found >= 0) {
          DebugLogger.log(`\u2705 Matched tieStart[${i}] -> tieEnd[${found}]`);
          const tgt = notePositions[found];
          const endX = tgt.headLeftX !== void 0 ? tgt.headLeftX : tgt.x;
          let endY;
          if (tgt.headLeftX !== void 0) {
            const halfT = Math.abs(tgt.headLeftX - tgt.x);
            endY = halfT >= 6 ? tgt.y : tgt.y + halfT;
          } else {
            endY = tgt.y - 8;
          }
          drawCurve(startX, startY, endX, endY, cur.measureIndex !== tgt.measureIndex);
          matched.add(i);
          matched.add(found);
          continue;
        }
        DebugLogger.log(`No direct tieEnd found for tieStart[${i}], searching for tieFromVoid`);
        let foundFromVoid = -1;
        for (let j = i + 1; j < notePositions.length; j++) {
          if (matched.has(j)) continue;
          const cand = notePositions[j];
          if (cand.tieFromVoid) {
            foundFromVoid = j;
            break;
          }
        }
        if (foundFromVoid >= 0) {
          DebugLogger.log(`\u2705 Matched tieStart[${i}] -> tieFromVoid[${foundFromVoid}]`);
          const tgt = notePositions[foundFromVoid];
          const endX = tgt.headLeftX !== void 0 ? tgt.headLeftX : tgt.x;
          let endY;
          if (tgt.headLeftX !== void 0) {
            const halfT = Math.abs(tgt.headLeftX - tgt.x);
            endY = halfT >= 6 ? tgt.y : tgt.y + halfT;
          } else {
            endY = tgt.y - 8;
          }
          drawCurve(startX, startY, endX, endY, true);
          matched.add(i);
          matched.add(foundFromVoid);
          continue;
        }
        DebugLogger.log(`No tieFromVoid found, checking tieToVoid flag`);
        if (cur.tieToVoid) {
          DebugLogger.log(`Drawing tieToVoid for index ${i}`);
          const pending = drawHalfToMargin(startX, startY, svgWidth);
          tieManager.addPendingTie(cur.measureIndex, pending.x, pending.y);
          matched.add(i);
          continue;
        }
        DebugLogger.warn(`tieStart[${i}] has no match and no tieToVoid flag`);
      }
      if (cur.tieFromVoid && !matched.has(i)) {
        DebugLogger.log(`Found tieFromVoid at index ${i}`, {
          measure: cur.measureIndex
        });
        const pending = tieManager.resolvePendingFor(cur.measureIndex);
        let endX = cur.headLeftX !== void 0 ? cur.headLeftX : cur.x;
        let endY;
        if (cur.headLeftX !== void 0) {
          const half = Math.abs(cur.headLeftX - cur.x);
          endY = half >= 6 ? cur.y : cur.y + half;
        } else {
          endY = cur.y - 8;
        }
        if (pending) {
          DebugLogger.log(`\u2705 Resolved pending tie for tieFromVoid[${i}]`, pending);
          drawCurve(pending.x, pending.y, endX, endY, true);
          matched.add(i);
        } else {
          DebugLogger.log(`\u26A0\uFE0F No pending tie found, drawing from left margin`);
          const leftMarginX = 16;
          drawCurve(leftMarginX, endY, endX, endY, true);
          matched.add(i);
        }
      }
    }
    DebugLogger.log("\u{1F517} Tie detection completed", {
      totalMatched: matched.size,
      totalNotes: notePositions.length
    });
  }
};

// main.ts
var ChordGridPlugin = class extends import_obsidian.Plugin {
  /**
   * Méthode appelée lors du chargement du plugin.
   * 
   * Enregistre le processeur de blocs de code pour le langage `chordgrid`.
   * Ce processeur :
   * 1. Parse le contenu du bloc avec ChordGridParser
   * 2. Valide la durée des mesures par rapport à la signature temporelle
   * 3. Affiche les erreurs de validation le cas échéant
   * 4. Rend la grille en SVG avec SVGRenderer
   * 
   * En cas d'erreur de parsing, affiche un message d'erreur formaté.
   */
  async onload() {
    console.log("Loading Chord Grid Plugin");
    this.registerMarkdownCodeBlockProcessor(
      "chordgrid",
      (source, el, ctx) => {
        var _a;
        try {
          DebugLogger.init(el);
          DebugLogger.log("\u{1F3B5} Parsing chord grid", { source: source.substring(0, 100) + "..." });
          const parser = new ChordGridParser();
          const result = parser.parse(source);
          const grid = result.grid;
          DebugLogger.log("\u2705 Parsing completed", {
            measuresCount: grid.measures.length,
            timeSignature: `${grid.timeSignature.numerator}/${grid.timeSignature.denominator}`
          });
          if (result.errors && result.errors.length > 0) {
            DebugLogger.warn("Validation errors found", { count: result.errors.length });
            const pre = el.createEl("pre", { cls: "chord-grid-error" });
            pre.setText("Rhythm validation errors:\n" + result.errors.map((e) => e.message).join("\n"));
          }
          DebugLogger.log("\u{1F3A8} Starting SVG rendering");
          const renderer = new SVGRenderer();
          const svg = renderer.render(grid);
          DebugLogger.log("\u2705 Rendering completed");
          el.appendChild(svg);
        } catch (err) {
          DebugLogger.error("Fatal error", err);
          const error = err;
          el.createEl("pre", {
            text: `Erreur: ${(_a = error == null ? void 0 : error.message) != null ? _a : String(err)}`,
            cls: "chord-grid-error"
          });
        }
      }
    );
  }
  /**
   * Méthode appelée lors du déchargement du plugin.
   * 
   * Permet de nettoyer les ressources si nécessaire.
   */
  onunload() {
    console.log("Unloading Chord Grid Plugin");
  }
};
