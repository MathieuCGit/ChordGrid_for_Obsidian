/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ChordGridPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/parser/ChordGridParser.ts
var ChordGridParser = class {
  parse(input) {
    const lines = input.trim().split("\n");
    const firstLine = lines[0];
    const timeSignature = this.parseTimeSignature(firstLine);
    const allMeasures = [];
    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
      const line = lines[lineIndex];
      const measures = this.parseLine(line, lineIndex === 0);
      if (measures.length > 0 && lineIndex < lines.length - 1) {
        measures[measures.length - 1].lineBreakAfter = true;
      }
      allMeasures.push(...measures);
    }
    const renderedLines = this.groupIntoLines(allMeasures, 4);
    const grid = {
      timeSignature,
      measures: allMeasures,
      lines: renderedLines
    };
    const errors = [];
    const expectedQuarterNotes = timeSignature.numerator * (4 / timeSignature.denominator);
    for (let mi = 0; mi < allMeasures.length; mi++) {
      const measure = allMeasures[mi];
      let foundQuarterNotes = 0;
      for (const beat of measure.beats) {
        for (const n of beat.notes) {
          if (!n.value) continue;
          const baseWhole = 1 / n.value;
          const dottedMultiplier = n.dotted ? 1.5 : 1;
          const whole = baseWhole * dottedMultiplier;
          foundQuarterNotes += whole * 4;
        }
      }
      const diff = Math.abs(foundQuarterNotes - expectedQuarterNotes);
      if (diff > 1e-6) {
        errors.push({
          measureIndex: mi,
          measureSource: measure.source,
          expectedQuarterNotes,
          foundQuarterNotes,
          message: `Measure ${mi + 1}: expected ${expectedQuarterNotes} quarter-notes, found ${foundQuarterNotes.toFixed(3)} (diff ${diff.toFixed(3)})`
        });
      }
    }
    return { grid, errors };
  }
  parseLine(line, isFirstLine) {
    if (isFirstLine) {
      line = line.replace(/^\d+\/\d+\s*/, "");
    }
    const measures = [];
    const tokens = [];
    const re = /(\|\|:|:?\|\||\|)/g;
    let lastIndex = 0;
    let m;
    const parts = [];
    while ((m = re.exec(line)) !== null) {
      const sep = m[0];
      const text = line.slice(lastIndex, m.index).trim();
      parts.push({ sep: null, text });
      parts.push({ sep, text: "" });
      lastIndex = re.lastIndex;
    }
    const trailing = line.slice(lastIndex).trim();
    if (trailing.length > 0) parts.push({ sep: null, text: trailing });
    let currentText = "";
    for (const p of parts) {
      if (p.sep === null) {
        if (p.text) {
          if (currentText.length > 0) currentText += " ";
          currentText += p.text;
        }
      } else {
        tokens.push({ bar: p.sep, content: currentText.trim() });
        currentText = "";
      }
    }
    if (currentText.trim().length > 0) {
      tokens.push({ bar: "|", content: currentText.trim() });
    }
    const measureRe = /^\s*([^\[]+?)?\s*(?:\[([^\]]*)\])?\s*$/;
    const analyzer = new BeamAndTieAnalyzer();
    const segmentRe = /(\s*)([^\[\]\s]+)?\s*\[([^\]]*)\]/g;
    const nonEmptyTokens = tokens.filter((t) => t.content.trim().length > 0);
    for (let ti = 0; ti < nonEmptyTokens.length; ti++) {
      const t = nonEmptyTokens[ti];
      const text = t.content;
      const bar = t.bar;
      const beats = [];
      let firstChord = "";
      let anySource = "";
      let m2;
      const isFirstMeasureOfLine = ti === 0;
      const isLastMeasureOfLine = ti === nonEmptyTokens.length - 1;
      const chordSegments = [];
      while ((m2 = segmentRe.exec(text)) !== null) {
        const leadingSpace = m2[1] || "";
        const chord = (m2[2] || "").trim();
        const rhythm = (m2[3] || "").trim();
        const sourceText = m2[0];
        if (!firstChord && chord) firstChord = chord;
        anySource += (anySource ? " " : "") + sourceText;
        if (rhythm.length > 0) {
          const hasSignificantSpace = leadingSpace.length > 0;
          const parsedBeats = analyzer.analyzeRhythmGroup(rhythm, chord, isFirstMeasureOfLine, isLastMeasureOfLine, hasSignificantSpace);
          chordSegments.push({
            chord,
            // utiliser l'accord actuel
            beats: parsedBeats
          });
          beats.push(...parsedBeats);
        }
      }
      console.log("Parsed chords:", chordSegments.map((s) => s.chord));
      measures.push({
        beats,
        chord: firstChord,
        // garder pour compatibilité
        chordSegments,
        // nouvelle propriété pour tous les accords
        barline: bar,
        lineBreakAfter: false,
        source: anySource || text
      });
    }
    return measures;
  }
  // Minimal implementation to avoid "this.parseTimeSignature is not a function"
  parseTimeSignature(line) {
    const m = /^\s*(\d+)\/(\d+)/.exec(line);
    if (m) {
      return {
        numerator: parseInt(m[1], 10),
        denominator: parseInt(m[2], 10)
      };
    }
    return { numerator: 4, denominator: 4 };
  }
  // Placeholder for grouping helper (kept as referenced; implement if missing)
  groupIntoLines(measures, perLine) {
    const lines = [];
    for (let i = 0; i < measures.length; i += perLine) {
      lines.push(measures.slice(i, i + perLine));
    }
    return lines;
  }
};
var BeamAndTieAnalyzer = class {
  constructor() {
    __publicField(this, "tieContext");
    // Garder le contexte du dernier groupe de notes pour détecter
    // si deux segments doivent être liés ou séparés
    __publicField(this, "rhythmContext");
    this.tieContext = {
      lastNote: null,
      crossMeasure: false,
      crossLine: false,
      pendingTieToVoid: false
    };
    this.rhythmContext = {
      lastGroupTime: 0,
      lastGroupHasSpace: false,
      lastBeamableNotes: []
    };
  }
  analyzeRhythmGroup(rhythmStr, chord, isFirstMeasureOfLine, isLastMeasureOfLine, hasSignificantSpace = false) {
    var _a, _b, _c;
    this.rhythmContext.lastGroupHasSpace = hasSignificantSpace;
    const beats = [];
    let currentBeat = [];
    let i = 0;
    while (i < rhythmStr.length) {
      if (rhythmStr[i] === "_") {
        if (i === rhythmStr.length - 1 && isLastMeasureOfLine) {
          this.markTieToVoid(currentBeat);
        } else if (i === 0 && isFirstMeasureOfLine) {
          this.tieContext.pendingTieToVoid = false;
        } else {
          this.markTieStart(currentBeat);
        }
        i++;
        continue;
      }
      if (rhythmStr[i] === " ") {
        if (currentBeat.length > 0) {
          beats.push(this.createBeat(currentBeat));
          currentBeat = [];
        }
        i++;
        continue;
      }
      if (rhythmStr[i] === "-") {
        i++;
        const note2 = this.parseNote(rhythmStr, i);
        note2.isRest = true;
        currentBeat.push(note2);
        i += (_a = note2.length) != null ? _a : 0;
        continue;
      }
      const note = this.parseNote(rhythmStr, i);
      if (i === 0 && isFirstMeasureOfLine && rhythmStr[0] === "_") {
        note.tieFromVoid = true;
      }
      if ((_b = this.tieContext.lastNote) == null ? void 0 : _b.tieStart) {
        note.tieEnd = true;
        this.tieContext.lastNote = null;
      }
      currentBeat.push(note);
      i += (_c = note.length) != null ? _c : 0;
    }
    if (currentBeat.length > 0) {
      beats.push(this.createBeat(currentBeat));
    }
    return beats;
  }
  markTieToVoid(notes) {
    if (notes.length > 0) {
      const lastNote = notes[notes.length - 1];
      lastNote.tieStart = true;
      lastNote.tieToVoid = true;
      this.tieContext.pendingTieToVoid = true;
    }
  }
  parseNote(rhythmStr, startIndex) {
    const VALID = ["64", "32", "16", "8", "4", "2", "1"];
    for (const v of VALID) {
      if (rhythmStr.startsWith(v, startIndex)) {
        let len = v.length;
        let dotted = false;
        if (startIndex + len < rhythmStr.length && rhythmStr[startIndex + len] === ".") {
          dotted = true;
          len += 1;
        }
        return {
          value: parseInt(v),
          dotted,
          tieStart: false,
          tieEnd: false,
          tieToVoid: false,
          tieFromVoid: false,
          isRest: false,
          position: startIndex,
          length: len
        };
      }
    }
    return {
      value: 4,
      dotted: false,
      tieStart: false,
      tieEnd: false,
      tieToVoid: false,
      tieFromVoid: false,
      isRest: false,
      position: startIndex,
      length: 1
    };
  }
  markTieStart(notes) {
    if (notes.length === 0) return;
    const last = notes[notes.length - 1];
    last.tieStart = true;
    this.tieContext.lastNote = last;
    this.tieContext.crossMeasure = true;
  }
  createBeat(notes) {
    const beatNotes = notes.map((n) => ({ ...n }));
    const beamGroups = [];
    let hasBeam = false;
    const beamableNotes = beatNotes.filter((n) => n.value >= 8 && !n.isRest);
    if (beamableNotes.length > 0) {
      const hasIncomingTie = beamableNotes[0].tieEnd || beamableNotes[0].tieFromVoid;
      if (!this.rhythmContext.lastGroupHasSpace && hasIncomingTie) {
        const lastBeamableCount = this.rhythmContext.lastBeamableNotes.length;
        beamGroups.push({
          startIndex: 0,
          endIndex: beamableNotes.length - 1,
          noteCount: lastBeamableCount + beamableNotes.length
        });
        hasBeam = true;
      } else {
        beamGroups.push({
          startIndex: 0,
          endIndex: beamableNotes.length - 1,
          noteCount: beamableNotes.length
        });
        hasBeam = beamableNotes.length > 1;
      }
    }
    this.rhythmContext.lastBeamableNotes = beamableNotes;
    return {
      notes: beatNotes,
      hasBeam,
      beamGroups
    };
  }
  // ...existing code...
};

// src/renderer/constants.ts
var SVG_NS = "http://www.w3.org/2000/svg";

// src/renderer/MeasureRenderer.ts
var MeasureRenderer = class {
  constructor(measure, x, y, width) {
    this.measure = measure;
    this.x = x;
    this.y = y;
    this.width = width;
  }
  drawMeasure(svg, measureIndex, notePositions, grid) {
    const leftBarX = this.x;
    const rightBarX = this.x + this.width - 2;
    if (measureIndex === 0) {
      this.drawBar(svg, leftBarX, this.y, 120);
    } else if (this.measure.isRepeatStart) {
      this.drawBarWithRepeat(svg, leftBarX, this.y, 120, true);
    }
    const staffLineY = this.y + 80;
    const staffLine = document.createElementNS(SVG_NS, "line");
    staffLine.setAttribute("x1", (this.x + 10).toString());
    staffLine.setAttribute("y1", staffLineY.toString());
    staffLine.setAttribute("x2", (this.x + this.width - 10).toString());
    staffLine.setAttribute("y2", staffLineY.toString());
    staffLine.setAttribute("stroke", "#000");
    staffLine.setAttribute("stroke-width", "1");
    svg.appendChild(staffLine);
    const segments = this.measure.chordSegments || [{ chord: this.measure.chord, beats: this.measure.beats }];
    const segmentWidth = this.width / segments.length;
    segments.forEach((segment, segmentIndex) => {
      const segmentX = this.x + segmentIndex * segmentWidth + 10;
      const beatsWidth = segmentWidth - 20;
      const beatWidth = beatsWidth / segment.beats.length;
      segment.beats.forEach((beat, beatIndex) => {
        const beatX = segmentX + beatIndex * beatWidth;
        const firstNoteX = this.drawRhythm(svg, beat, beatX, staffLineY, beatWidth, measureIndex, segmentIndex, beatIndex, notePositions);
        if (firstNoteX !== null && beatIndex === 0 && segment.chord) {
          const chordText = this.createText(segment.chord, firstNoteX, this.y + 40, "22px", "bold");
          chordText.setAttribute("text-anchor", "middle");
          chordText.setAttribute("font-family", "Arial, sans-serif");
          svg.appendChild(chordText);
        }
      });
    });
    if (this.measure.isRepeatEnd) {
      this.drawBarWithRepeat(svg, rightBarX, this.y, 120, false);
    } else if (this.measure.barline || measureIndex === grid.measures.length - 1) {
      this.drawBar(svg, rightBarX, this.y, 120);
    }
  }
  drawRhythm(svg, beat, x, staffLineY, width, measureIndex, chordIndex, beatIndex, notePositions) {
    const beats = [beat];
    const beatWidth = width;
    let currentX = x;
    let firstNoteX = null;
    const first = this.drawBeat(svg, beat, currentX, staffLineY, beatWidth, measureIndex, chordIndex, beatIndex, notePositions);
    if (first !== null) firstNoteX = first;
    return firstNoteX;
  }
  drawBeat(svg, beat, x, staffLineY, width, measureIndex, chordIndex, beatIndex, notePositions) {
    if (!beat || beat.notes.length === 0) return null;
    const hasBeamableNotes = beat.notes.some((n) => n.value >= 8 || n.tieStart || n.tieEnd || n.tieToVoid || n.tieFromVoid);
    if (hasBeamableNotes || beat.notes.length > 1) {
      const firstNoteX = this.drawNoteGroup(svg, beat.notes, x + 10, staffLineY, width);
      beat.notes.forEach((nv, noteIndex) => {
        const noteX = x + 10 + noteIndex * (width / beat.notes.length) + width / beat.notes.length / 2;
        notePositions.push({
          x: noteX,
          y: staffLineY,
          measureIndex,
          chordIndex,
          beatIndex,
          noteIndex,
          tied: !!(nv.tieStart || nv.tieEnd || nv.tieToVoid || nv.tieFromVoid)
        });
      });
      return firstNoteX;
    } else {
      const nv = beat.notes[0];
      const noteX = this.drawSingleNote(svg, nv, x + 10, staffLineY, width);
      notePositions.push({
        x: noteX,
        y: staffLineY,
        measureIndex,
        chordIndex,
        beatIndex,
        noteIndex: 0,
        tied: !!(nv.tieStart || nv.tieEnd || nv.tieToVoid || nv.tieFromVoid)
      });
      return noteX;
    }
  }
  drawSingleNote(svg, nv, x, staffLineY, width) {
    const centerX = x;
    if (nv.value === 1) {
      this.drawDiamondNoteHead(svg, centerX, staffLineY, true);
    } else if (nv.value === 2) {
      this.drawDiamondNoteHead(svg, centerX, staffLineY, true);
      this.drawStem(svg, centerX, staffLineY, 25);
    } else {
      this.drawSlash(svg, centerX, staffLineY);
      this.drawStem(svg, centerX, staffLineY, 25);
      if (nv.value === 8) this.drawFlag(svg, centerX, staffLineY, 1);
      else if (nv.value === 16) this.drawFlag(svg, centerX, staffLineY, 2);
      else if (nv.value === 32) this.drawFlag(svg, centerX, staffLineY, 3);
      else if (nv.value === 64) this.drawFlag(svg, centerX, staffLineY, 4);
    }
    if (nv.dotted) {
      const dot = document.createElementNS(SVG_NS, "circle");
      dot.setAttribute("cx", (centerX + 8).toString());
      dot.setAttribute("cy", staffLineY.toString());
      dot.setAttribute("r", "2");
      dot.setAttribute("fill", "#000");
      svg.appendChild(dot);
    }
    return centerX;
  }
  drawDiamondNoteHead(svg, x, y, hollow) {
    const diamondSize = 6;
    const diamond = document.createElementNS(SVG_NS, "polygon");
    const points = [[x, y - diamondSize], [x + diamondSize, y], [x, y + diamondSize], [x - diamondSize, y]];
    diamond.setAttribute("points", points.map((p) => `${p[0]},${p[1]}`).join(" "));
    diamond.setAttribute("fill", hollow ? "white" : "black");
    diamond.setAttribute("stroke", "#000");
    diamond.setAttribute("stroke-width", "1");
    svg.appendChild(diamond);
  }
  drawNoteGroup(svg, notesValues, x, staffLineY, width) {
    const noteCount = notesValues.length;
    if (noteCount === 0) return null;
    const hasSmallNotes = notesValues.some((nv) => nv.value >= 32);
    const noteSpacing = noteCount > 0 ? width / noteCount * (hasSmallNotes ? 1.2 : 1) : width;
    const stemHeight = 25;
    if (noteCount === 1 && notesValues[0].value >= 8) {
      const centerX = x;
      this.drawSlash(svg, centerX, staffLineY);
      const stem = this.drawStem(svg, centerX, staffLineY, stemHeight);
      const value = notesValues[0].value;
      this.drawFlag(svg, centerX, staffLineY, value === 8 ? 1 : value === 16 ? 2 : value === 32 ? 3 : value === 64 ? 4 : 0);
      return centerX;
    }
    const notes = [];
    for (let i = 0; i < noteCount; i++) {
      const nv = notesValues[i];
      const centerX = x + i * noteSpacing;
      if (nv.value === 1) {
        this.drawDiamondNoteHead(svg, centerX, staffLineY, true);
        notes.push({ nv, beamCount: 0, centerX });
      } else if (nv.value === 2) {
        this.drawDiamondNoteHead(svg, centerX, staffLineY, true);
        const stemInfo = this.drawStem(svg, centerX, staffLineY, stemHeight);
        notes.push({ nv, beamCount: 0, centerX, stemX: stemInfo.x, stemTopY: stemInfo.topY, stemBottomY: stemInfo.bottomY });
      } else {
        this.drawSlash(svg, centerX, staffLineY);
        const stemInfo = this.drawStem(svg, centerX, staffLineY, stemHeight);
        const prevNote = i > 0 ? notesValues[i - 1] : null;
        const nextNote = i < notesValues.length - 1 ? notesValues[i + 1] : null;
        const needsFlag = nv.value >= 8 && (!prevNote || prevNote.value < 8) && (!nextNote || nextNote.value < 8);
        if (needsFlag) {
          if (nv.value === 8) this.drawFlag(svg, centerX, staffLineY, 1);
          else if (nv.value === 16) this.drawFlag(svg, centerX, staffLineY, 2);
          else if (nv.value === 32) this.drawFlag(svg, centerX, staffLineY, 3);
          else if (nv.value === 64) this.drawFlag(svg, centerX, staffLineY, 4);
        }
        const beamCount = nv.value === 8 ? 1 : nv.value === 16 ? 2 : nv.value === 32 ? 3 : nv.value === 64 ? 4 : 0;
        notes.push({ nv, beamCount, centerX, stemX: stemInfo.x, stemTopY: stemInfo.topY, stemBottomY: stemInfo.bottomY });
      }
      if (nv.dotted) {
        const dot = document.createElementNS(SVG_NS, "circle");
        dot.setAttribute("cx", (centerX + 8).toString());
        dot.setAttribute("cy", staffLineY.toString());
        dot.setAttribute("r", "2");
        dot.setAttribute("fill", "#000");
        svg.appendChild(dot);
      }
    }
    const beamedNotes = notes.filter((n) => n.beamCount > 0);
    if (beamedNotes.length === 0) return notes.length ? notes[0].centerX : null;
    const maxBeamCount = Math.max(...beamedNotes.map((n) => n.beamCount));
    if (maxBeamCount === 0) return notes.length ? notes[0].centerX : null;
    const beamGap = 5;
    const validStemBottoms = beamedNotes.map((n) => n.stemBottomY).filter((y) => y !== void 0);
    const baseStemBottom = validStemBottoms.length > 0 ? Math.min(...validStemBottoms) : staffLineY + 30;
    for (let level = 1; level <= maxBeamCount; level++) {
      let segStartIndex = null;
      for (let i = 0; i < beamedNotes.length; i++) {
        const n = beamedNotes[i];
        const active = n.beamCount >= level;
        if (active && segStartIndex === null) {
          segStartIndex = i;
        } else if ((!active || i === beamedNotes.length - 1) && segStartIndex !== null) {
          const segEnd = active && i === beamedNotes.length - 1 ? i : i - 1;
          const beamY = baseStemBottom - (level - 1) * beamGap;
          const startX = beamedNotes[segStartIndex].stemX;
          const endX = beamedNotes[segEnd].stemX;
          const beam = document.createElementNS(SVG_NS, "line");
          beam.setAttribute("x1", startX.toString());
          beam.setAttribute("y1", beamY.toString());
          beam.setAttribute("x2", endX.toString());
          beam.setAttribute("y2", beamY.toString());
          beam.setAttribute("stroke", "#000");
          beam.setAttribute("stroke-width", "2");
          svg.appendChild(beam);
          segStartIndex = null;
        }
      }
    }
    return notes.length ? notes[0].centerX : null;
  }
  drawSlash(svg, x, y) {
    const slashLength = 10;
    const slash = document.createElementNS(SVG_NS, "line");
    slash.setAttribute("x1", (x + slashLength / 2).toString());
    slash.setAttribute("y1", (y - slashLength / 2).toString());
    slash.setAttribute("x2", (x - slashLength / 2).toString());
    slash.setAttribute("y2", (y + slashLength / 2).toString());
    slash.setAttribute("stroke", "#000");
    slash.setAttribute("stroke-width", "3");
    svg.appendChild(slash);
  }
  drawStem(svg, x, y, height) {
    const slashLength = 10;
    const stemStartX = x - slashLength / 2 + 2;
    const stemStartY = y + slashLength / 2;
    const stem = document.createElementNS(SVG_NS, "line");
    stem.setAttribute("x1", stemStartX.toString());
    stem.setAttribute("y1", stemStartY.toString());
    stem.setAttribute("x2", stemStartX.toString());
    stem.setAttribute("y2", (stemStartY + height).toString());
    stem.setAttribute("stroke", "#000");
    stem.setAttribute("stroke-width", "2");
    svg.appendChild(stem);
    return { x: stemStartX, topY: stemStartY, bottomY: stemStartY + height };
  }
  drawFlag(svg, x, staffLineY, count) {
    const slashLength = 10;
    const stemStartX = x - slashLength / 2 + 2;
    const stemBottomY = staffLineY + slashLength / 2 + 25;
    for (let i = 0; i < count; i++) {
      const flag = document.createElementNS(SVG_NS, "path");
      const flagY = stemBottomY - i * 10;
      flag.setAttribute("d", `M ${stemStartX} ${flagY} Q ${stemStartX - 10} ${flagY - 5} ${stemStartX - 8} ${flagY - 12}`);
      flag.setAttribute("stroke", "#000");
      flag.setAttribute("stroke-width", "2");
      flag.setAttribute("fill", "none");
      svg.appendChild(flag);
    }
  }
  drawBar(svg, x, y, height) {
    const line = document.createElementNS(SVG_NS, "line");
    line.setAttribute("x1", x.toString());
    line.setAttribute("y1", y.toString());
    line.setAttribute("x2", x.toString());
    line.setAttribute("y2", (y + height).toString());
    line.setAttribute("stroke", "#000");
    line.setAttribute("stroke-width", "1.5");
    svg.appendChild(line);
  }
  drawBarWithRepeat(svg, x, y, height, isStart) {
    this.drawDoubleBar(svg, x, y, height);
    const dotOffset = isStart ? 12 : -12;
    const dot1Y = y + height * 0.35;
    const dot2Y = y + height * 0.65;
    [dot1Y, dot2Y].forEach((dotY) => {
      const circle = document.createElementNS(SVG_NS, "circle");
      circle.setAttribute("cx", (x + dotOffset).toString());
      circle.setAttribute("cy", dotY.toString());
      circle.setAttribute("r", "2");
      circle.setAttribute("fill", "#000");
      svg.appendChild(circle);
    });
  }
  drawDoubleBar(svg, x, y, height) {
    const bar1 = document.createElementNS(SVG_NS, "line");
    bar1.setAttribute("x1", x.toString());
    bar1.setAttribute("y1", y.toString());
    bar1.setAttribute("x2", x.toString());
    bar1.setAttribute("y2", (y + height).toString());
    bar1.setAttribute("stroke", "#000");
    bar1.setAttribute("stroke-width", "1.5");
    svg.appendChild(bar1);
    const bar2 = document.createElementNS(SVG_NS, "line");
    bar2.setAttribute("x1", (x + 6).toString());
    bar2.setAttribute("y1", y.toString());
    bar2.setAttribute("x2", (x + 6).toString());
    bar2.setAttribute("y2", (y + height).toString());
    bar2.setAttribute("stroke", "#000");
    bar2.setAttribute("stroke-width", "1.5");
    svg.appendChild(bar2);
  }
  createText(text, x, y, size, weight = "normal") {
    const textEl = document.createElementNS(SVG_NS, "text");
    textEl.setAttribute("x", x.toString());
    textEl.setAttribute("y", y.toString());
    textEl.setAttribute("font-family", "Arial, sans-serif");
    textEl.setAttribute("font-size", size);
    textEl.setAttribute("font-weight", weight);
    textEl.setAttribute("fill", "#000");
    textEl.textContent = text;
    return textEl;
  }
};

// src/renderer/SVGRenderer.ts
var SVGRenderer = class {
  render(grid) {
    return this.createSVG(grid);
  }
  createSVG(grid) {
    const measuresPerLine = 4;
    const measureWidth = 200;
    const measureHeight = 120;
    let currentLine = 0;
    let measuresInCurrentLine = 0;
    const measurePositions = [];
    let globalIndex = 0;
    grid.measures.forEach((measure) => {
      if (measure.isLineBreak) {
        currentLine++;
        measuresInCurrentLine = 0;
        return;
      }
      if (measuresInCurrentLine >= measuresPerLine) {
        currentLine++;
        measuresInCurrentLine = 0;
      }
      measurePositions.push({ measure, lineIndex: currentLine, posInLine: measuresInCurrentLine, globalIndex: globalIndex++ });
      measuresInCurrentLine++;
    });
    const lines = currentLine + 1;
    const width = measuresPerLine * measureWidth + 60;
    const height = lines * (measureHeight + 20) + 20;
    const svg = document.createElementNS(SVG_NS, "svg");
    svg.setAttribute("width", String(width));
    svg.setAttribute("height", String(height));
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    svg.setAttribute("xmlns", SVG_NS);
    const bg = document.createElementNS(SVG_NS, "rect");
    bg.setAttribute("x", "0");
    bg.setAttribute("y", "0");
    bg.setAttribute("width", String(width));
    bg.setAttribute("height", String(height));
    bg.setAttribute("fill", "white");
    svg.appendChild(bg);
    const timeSig = `${grid.timeSignature.numerator}/${grid.timeSignature.denominator}`;
    const timeText = this.createText(timeSig, 10, 40, "18px", "bold");
    svg.appendChild(timeText);
    const notePositions = [];
    measurePositions.forEach(({ measure, lineIndex, posInLine, globalIndex: globalIndex2 }) => {
      const x = posInLine * measureWidth + 40;
      const y = lineIndex * (measureHeight + 20) + 20;
      const mr = new MeasureRenderer(measure, x, y, measureWidth);
      mr.drawMeasure(svg, globalIndex2, notePositions, grid);
    });
    this.detectAndDrawTies(svg, notePositions);
    return svg;
  }
  createText(text, x, y, size, weight = "normal") {
    const textEl = document.createElementNS(SVG_NS, "text");
    textEl.setAttribute("x", String(x));
    textEl.setAttribute("y", String(y));
    textEl.setAttribute("font-family", "Arial, sans-serif");
    textEl.setAttribute("font-size", size);
    textEl.setAttribute("font-weight", weight);
    textEl.setAttribute("fill", "#000");
    textEl.textContent = text;
    return textEl;
  }
  detectAndDrawTies(svg, notePositions) {
    const ties = [];
    for (let i = 0; i < notePositions.length - 1; i++) {
      const current = notePositions[i];
      const next = notePositions[i + 1];
      if (current.tied && current.measureIndex === next.measureIndex) {
        ties.push({
          startX: current.x,
          startY: current.y - 8,
          endX: next.x,
          endY: next.y - 8
        });
      }
    }
    for (let i = 0; i < notePositions.length; i++) {
      const current = notePositions[i];
      if (current.tied) {
        const isLastInMeasure = !notePositions[i + 1] || notePositions[i + 1].measureIndex > current.measureIndex;
        if (isLastInMeasure) {
          for (let j = 0; j < notePositions.length; j++) {
            const target = notePositions[j];
            if (target.measureIndex === current.measureIndex + 1) {
              ties.push({
                startX: current.x,
                startY: current.y - 8,
                endX: target.x,
                endY: target.y - 8,
                isCrossMeasure: true
              });
              break;
            }
          }
        }
      }
    }
    for (const t of ties) {
      const path = document.createElementNS(SVG_NS, "path");
      const controlY = t.startY - (t.isCrossMeasure ? 15 : 5);
      const midX = (t.startX + t.endX) / 2;
      let d;
      if (t.isCrossMeasure) {
        d = `M ${t.startX} ${t.startY} C ${t.startX + 30} ${controlY}, ${t.endX - 30} ${controlY}, ${t.endX} ${t.endY}`;
      } else {
        d = `M ${t.startX} ${t.startY} Q ${midX} ${controlY} ${t.endX} ${t.endY}`;
      }
      path.setAttribute("d", d);
      path.setAttribute("stroke", "#000");
      path.setAttribute("stroke-width", "1.5");
      path.setAttribute("fill", "none");
      svg.appendChild(path);
    }
  }
};

// main.ts
var ChordGridPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Loading Chord Grid Plugin");
    this.registerMarkdownCodeBlockProcessor(
      "chordgrid",
      (source, el, ctx) => {
        var _a;
        try {
          const parser = new ChordGridParser();
          const result = parser.parse(source);
          const grid = result.grid;
          if (result.errors && result.errors.length > 0) {
            const pre = el.createEl("pre", { cls: "chord-grid-error" });
            pre.setText("Rhythm validation errors:\n" + result.errors.map((e) => e.message).join("\n"));
          }
          const renderer = new SVGRenderer();
          const svg = renderer.render(grid);
          el.appendChild(svg);
        } catch (err) {
          const error = err;
          el.createEl("pre", {
            text: `Erreur: ${(_a = error == null ? void 0 : error.message) != null ? _a : String(err)}`,
            cls: "chord-grid-error"
          });
        }
      }
    );
  }
  onunload() {
    console.log("Unloading Chord Grid Plugin");
  }
};
