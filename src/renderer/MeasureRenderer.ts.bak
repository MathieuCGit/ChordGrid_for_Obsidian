import { Measure, Beat, NoteElement, ChordGrid, ChordSegment } from '../parser/type';
import { SVG_NS } from './constants';

interface NotePosition {
    x: number;
    y: number;
    measureIndex: number;
    chordIndex: number;
    beatIndex: number;
    noteIndex: number;
    tied: boolean;
}

export class MeasureRenderer {
    constructor(
        private readonly measure: Measure,
        private readonly x: number,
        private readonly y: number,
        private readonly width: number
    ) {}

    public drawMeasure(
        svg: SVGElement,
        measureIndex: number,
        notePositions: Array<{
            x: number;
            y: number;
            measureIndex: number;
            chordIndex: number;
            beatIndex: number;
            noteIndex: number;
            tied: boolean;
        }>,
        grid: ChordGrid
    ): void {

  // match call used by SVGRenderer
    public drawMeasure(svg: SVGElement, measureIndex: number, notePositions: NotePosition[], grid: ChordGrid): void {
    const leftBarX = this.x;
    const rightBarX = this.x + this.width - 2;

    if (measureIndex === 0) {
      this.drawBar(svg, leftBarX, this.y, 120);
    } else if ((this.measure as any).isRepeatStart) {
      this.drawBarWithRepeat(svg, leftBarX, this.y, 120, true);
    }

    // staff line
    const staffLineY = this.y + 80;
    const staffLine = document.createElementNS(SVG_NS, 'line');
    staffLine.setAttribute('x1', (this.x + 10).toString());
    staffLine.setAttribute('y1', staffLineY.toString());
    staffLine.setAttribute('x2', (this.x + this.width - 10).toString());
    staffLine.setAttribute('y2', staffLineY.toString());
    staffLine.setAttribute('stroke', '#000');
    staffLine.setAttribute('stroke-width', '1');
    svg.appendChild(staffLine);

    // Support multiple chord segments per measure
    console.log("Measure:", this.measure);
    const segments: ChordSegment[] = this.measure.chordSegments || [{ chord: this.measure.chord, beats: this.measure.beats }];
    console.log("Using segments:", segments.map(s => s.chord));
    const segmentWidth = this.width / segments.length;
    
    // draw beats and collect notePositions per chord segment
    segments.forEach((segment: ChordSegment, segmentIndex: number) => {
      const segmentX = this.x + (segmentIndex * segmentWidth) + 10;
      const beatsWidth = segmentWidth - 20;
      const beatWidth = beatsWidth / segment.beats.length;
      
      // draw beats
      segment.beats.forEach((beat: Beat, beatIndex: number) => {
        const beatX = segmentX + (beatIndex * beatWidth);
        const firstNoteX = this.drawRhythm(svg, beat, beatX, staffLineY, beatWidth, measureIndex, segmentIndex, beatIndex, notePositions);
        
        if (firstNoteX !== null && beatIndex === 0 && segment.chord) {
          const chordText = this.createText(segment.chord, firstNoteX, this.y + 40, '22px', 'bold');
          chordText.setAttribute('text-anchor', 'middle');
          chordText.setAttribute('font-family', 'Arial, sans-serif');
          svg.appendChild(chordText);
        }
      });
    });

    if ((this.measure as any).isRepeatEnd) {
      this.drawBarWithRepeat(svg, rightBarX, this.y, 120, false);
    } else if ((this.measure as any).barline || measureIndex === (grid.measures.length - 1)) {
      this.drawBar(svg, rightBarX, this.y, 120);
    }
  }

  private drawDoubleBar(svg: SVGElement, x: number, y: number, height: number): void {
    const bar1 = document.createElementNS(SVG_NS, 'line');
    bar1.setAttribute('x1', x.toString());
    bar1.setAttribute('y1', y.toString());
    bar1.setAttribute('x2', x.toString());
    bar1.setAttribute('y2', (y + height).toString());
    bar1.setAttribute('stroke', '#000');
    bar1.setAttribute('stroke-width', '1.5');
    svg.appendChild(bar1);

    const bar2 = document.createElementNS(SVG_NS, 'line');
    bar2.setAttribute('x1', (x + 6).toString());
    bar2.setAttribute('y1', y.toString());
    bar2.setAttribute('x2', (x + 6).toString());
    bar2.setAttribute('y2', (y + height).toString());
    bar2.setAttribute('stroke', '#000');
    bar2.setAttribute('stroke-width', '1.5');
    svg.appendChild(bar2);
  }

  private drawBarWithRepeat(svg: SVGElement, x: number, y: number, height: number, isStart: boolean): void {
    this.drawDoubleBar(svg, x, y, height);
    const dotOffset = isStart ? 12 : -12;
    const dot1Y = y + height * 0.35;
    const dot2Y = y + height * 0.65;
    [dot1Y, dot2Y].forEach(dotY => {
      const circle = document.createElementNS(SVG_NS, 'circle');
      circle.setAttribute('cx', (x + dotOffset).toString());
      circle.setAttribute('cy', dotY.toString());
      circle.setAttribute('r', '2');
      circle.setAttribute('fill', '#000');
      svg.appendChild(circle);
    });
  }

  private drawBar(svg: SVGElement, x: number, y: number, height: number): void {
    const line = document.createElementNS(SVG_NS, 'line');
    line.setAttribute('x1', x.toString());
    line.setAttribute('y1', y.toString());
    line.setAttribute('x2', x.toString());
    line.setAttribute('y2', (y + height).toString());
    line.setAttribute('stroke', '#000');
    line.setAttribute('stroke-width', '1.5');
    svg.appendChild(line);
  }

  drawRhythm(svg: SVGElement, beat: Beat, x: number, staffLineY: number, width: number, measureIndex: number, chordIndex: number, beatIndex: number, notePositions: {x:number,y:number,measureIndex:number,chordIndex:number,beatIndex:number,noteIndex:number,tied:boolean}[]): number | null {
    const beats = [beat];
    const beatWidth = width; // caller already provides split width per beat
    let currentX = x;
    let firstNoteX: number | null = null;

    // Since we call drawRhythm per beat, handle it directly
    const first = this.drawBeat(svg, beat, currentX, staffLineY, beatWidth, measureIndex, chordIndex, beatIndex, notePositions);
    if (first !== null) firstNoteX = first;

    return firstNoteX;
  }

  drawBeat(svg: SVGElement, beat: Beat, x: number, staffLineY: number, width: number, measureIndex: number, chordIndex: number, beatIndex: number, notePositions: {x:number,y:number,measureIndex:number,chordIndex:number,beatIndex:number,noteIndex:number,tied:boolean}[]): number | null {
    if (!beat || beat.notes.length === 0) return null;
    
    // Utilisez toujours drawNoteGroup pour les notes liÃ©es ou avec des valeurs >= 8
    const hasBeamableNotes = beat.notes.some(n => n.value >= 8 || n.tieStart || n.tieEnd || n.tieToVoid || n.tieFromVoid);
    
    if (hasBeamableNotes || beat.notes.length > 1) {
      const firstNoteX = this.drawNoteGroup(svg, beat.notes as any, x + 10, staffLineY, width);
      beat.notes.forEach((nv, noteIndex) => {
        const noteX = x + 10 + (noteIndex * (width / beat.notes.length)) + (width / beat.notes.length) / 2;
        notePositions.push({ x: noteX, y: staffLineY, measureIndex, chordIndex, beatIndex, noteIndex, tied: !!(nv.tieStart || nv.tieEnd || nv.tieToVoid || nv.tieFromVoid) });
      });
      return firstNoteX;
    } else {
      const nv = beat.notes[0];
      const noteX = this.drawSingleNote(svg, nv, x + 10, staffLineY, width);
      notePositions.push({ x: noteX, y: staffLineY, measureIndex, chordIndex, beatIndex, noteIndex: 0, tied: !!(nv.tieStart || nv.tieEnd || nv.tieToVoid || nv.tieFromVoid) });
      return noteX;
    }
  }
  }

  drawSingleNote(svg: SVGElement, nv: NoteElement, x: number, staffLineY: number, width: number): number {
    const centerX = x;
    if (nv.value === 1) {
      this.drawDiamondNoteHead(svg, centerX, staffLineY, true);
    } else if (nv.value === 2) {
      this.drawDiamondNoteHead(svg, centerX, staffLineY, true);
      this.drawStem(svg, centerX, staffLineY, 25);
    } else {
      this.drawSlash(svg, centerX, staffLineY);
      this.drawStem(svg, centerX, staffLineY, 25);
      if (nv.value === 8) this.drawFlag(svg, centerX, staffLineY, 1);
      else if (nv.value === 16) this.drawFlag(svg, centerX, staffLineY, 2);
      else if (nv.value === 32) this.drawFlag(svg, centerX, staffLineY, 3);
      else if (nv.value === 64) this.drawFlag(svg, centerX, staffLineY, 4);
    }

    if (nv.dotted) {
      const dot = document.createElementNS(SVG_NS, 'circle');
      dot.setAttribute('cx', (centerX + 8).toString());
      dot.setAttribute('cy', (staffLineY).toString());
      dot.setAttribute('r', '2');
      dot.setAttribute('fill', '#000');
      svg.appendChild(dot);
    }

    return centerX;
  }

  drawDiamondNoteHead(svg: SVGElement, x: number, y: number, hollow: boolean) {
    const diamondSize = 6;
    const diamond = document.createElementNS(SVG_NS, 'polygon');
    const points = [ [x, y - diamondSize], [x + diamondSize, y], [x, y + diamondSize], [x - diamondSize, y] ];
    diamond.setAttribute('points', points.map(p => `${p[0]},${p[1]}`).join(' '));
    diamond.setAttribute('fill', hollow ? 'white' : 'black');
    diamond.setAttribute('stroke', '#000');
    diamond.setAttribute('stroke-width', '1');
    svg.appendChild(diamond);
  }

  drawNoteGroup(svg: SVGElement, notesValues: NoteElement[], x: number, staffLineY: number, width: number): number | null {
    const noteCount = notesValues.length;
    if (noteCount === 0) return null;
    const hasSmallNotes = notesValues.some(nv => nv.value >= 32);
    const noteSpacing = noteCount > 0 ? (width / noteCount) * (hasSmallNotes ? 1.2 : 1) : width;
    const stemHeight = 25;
    
    // Si une seule note avec valeur >= 8, on ajoute son crochet
    if (noteCount === 1 && notesValues[0].value >= 8) {
      const centerX = x;
      this.drawSlash(svg, centerX, staffLineY);
      const stem = this.drawStem(svg, centerX, staffLineY, stemHeight);
      const value = notesValues[0].value;
      this.drawFlag(svg, centerX, staffLineY, value === 8 ? 1 : value === 16 ? 2 : value === 32 ? 3 : value === 64 ? 4 : 0);
      return centerX;
    }

    const notes: any[] = [];
    for (let i = 0; i < noteCount; i++) {
      const nv = notesValues[i];
      const centerX = x + i * noteSpacing;
      if (nv.value === 1) {
        this.drawDiamondNoteHead(svg, centerX, staffLineY, true);
        notes.push({ nv, beamCount: 0, centerX });
      } else if (nv.value === 2) {
        this.drawDiamondNoteHead(svg, centerX, staffLineY, true);
        const stemInfo = this.drawStem(svg, centerX, staffLineY, stemHeight);
        notes.push({ nv, beamCount: 0, centerX, stemX: stemInfo.x, stemTopY: stemInfo.topY, stemBottomY: stemInfo.bottomY });
      } else {
        this.drawSlash(svg, centerX, staffLineY);
        const stemInfo = this.drawStem(svg, centerX, staffLineY, stemHeight);
        // Toujours dessiner le flag pour les notes >= 8 si elles n'ont pas de voisin
        const prevNote = i > 0 ? notesValues[i - 1] : null;
        const nextNote = i < notesValues.length - 1 ? notesValues[i + 1] : null;
        const needsFlag = nv.value >= 8 && (!prevNote || prevNote.value < 8) && (!nextNote || nextNote.value < 8);
        
        if (needsFlag) {
          if (nv.value === 8) this.drawFlag(svg, centerX, staffLineY, 1);
          else if (nv.value === 16) this.drawFlag(svg, centerX, staffLineY, 2);
          else if (nv.value === 32) this.drawFlag(svg, centerX, staffLineY, 3);
          else if (nv.value === 64) this.drawFlag(svg, centerX, staffLineY, 4);
        }
        
        const beamCount = nv.value === 8 ? 1 : nv.value === 16 ? 2 : nv.value === 32 ? 3 : nv.value === 64 ? 4 : 0;
        notes.push({ nv, beamCount, centerX, stemX: stemInfo.x, stemTopY: stemInfo.topY, stemBottomY: stemInfo.bottomY });
      }

      if (nv.dotted) {
        const dot = document.createElementNS(SVG_NS, 'circle');
        dot.setAttribute('cx', (centerX + 8).toString());
        dot.setAttribute('cy', (staffLineY).toString());
        dot.setAttribute('r', '2');
        dot.setAttribute('fill', '#000');
        svg.appendChild(dot);
      }
    }

    const beamedNotes = notes.filter(n => n.beamCount > 0);
    if (beamedNotes.length === 0) return notes.length ? notes[0].centerX : null;

    const maxBeamCount = beamedNotes.reduce((m, n) => Math.max(m, n.beamCount), 0);
    if (maxBeamCount === 0) return notes.length ? notes[0].centerX : null;

    const beamGap = 5;
    const validStemBottoms = beamedNotes.map(n => n.stemBottomY).filter(y => y !== undefined) as number[];
    const baseStemBottom = validStemBottoms.length > 0 ? Math.min(...validStemBottoms) : staffLineY + 30;

    for (let level = 1; level <= maxBeamCount; level++) {
      let segStartIndex: number | null = null;
      for (let i = 0; i < beamedNotes.length; i++) {
        const n = beamedNotes[i];
        const active = n.beamCount >= level;
        if (active && segStartIndex === null) {
          segStartIndex = i;
        } else if ((!active || i === beamedNotes.length - 1) && segStartIndex !== null) {
          const segEnd = (active && i === beamedNotes.length - 1) ? i : i - 1;
          const beamY = baseStemBottom - (level - 1) * beamGap;
          const startX = beamedNotes[segStartIndex].stemX!;
          const endX = beamedNotes[segEnd].stemX!;
          const beam = document.createElementNS(SVG_NS, 'line');
          beam.setAttribute('x1', startX.toString());
          beam.setAttribute('y1', beamY.toString());
          beam.setAttribute('x2', endX.toString());
          beam.setAttribute('y2', beamY.toString());
          beam.setAttribute('stroke', '#000');
          beam.setAttribute('stroke-width', '2');
          svg.appendChild(beam);
          segStartIndex = null;
        }
      }

      const stubLength = Math.max(8, noteSpacing * 0.4);
      for (let i = 0; i < beamedNotes.length; i++) {
        const n = beamedNotes[i];
        const hasLevel = n.beamCount >= level;
        if (!hasLevel) continue;
        const leftBeamCount = (i - 1 >= 0) ? beamedNotes[i - 1].beamCount : 0;
        const rightBeamCount = (i + 1 < beamedNotes.length) ? beamedNotes[i + 1].beamCount : 0;
        const leftHasLevel = leftBeamCount >= level;
        const rightHasLevel = rightBeamCount >= level;
        if (leftHasLevel && rightHasLevel) continue;
        if (!leftHasLevel && !rightHasLevel) {
          const beamY = baseStemBottom - (level - 1) * beamGap;
          const stemX = n.stemX!;
          const leftNote = i > 0 ? beamedNotes[i - 1] : null;
          const isAfterDottedStronger = leftNote && leftNote.nv.dotted && leftNote.nv.value < n.nv.value;
          const rightNote = i < beamedNotes.length - 1 ? beamedNotes[i + 1] : null;
          const isBeforeDottedWeaker = rightNote && rightNote.nv.dotted && n.nv.value < rightNote.nv.value;
          if (isAfterDottedStronger && i > 0) {
            const stubX = stemX - stubLength;
            const beam = document.createElementNS(SVG_NS, 'line');
            beam.setAttribute('x1', stemX.toString());
            beam.setAttribute('y1', beamY.toString());
            beam.setAttribute('x2', stubX.toString());
            beam.setAttribute('y2', beamY.toString());
            beam.setAttribute('stroke', '#000');
            beam.setAttribute('stroke-width', '2');
            svg.appendChild(beam);
          } else if (i < beamedNotes.length - 1) {
            const stubX = stemX + stubLength;
            const beam = document.createElementNS(SVG_NS, 'line');
            beam.setAttribute('x1', stemX.toString());
            beam.setAttribute('y1', beamY.toString());
            beam.setAttribute('x2', stubX.toString());
            beam.setAttribute('y2', beamY.toString());
            beam.setAttribute('stroke', '#000');
            beam.setAttribute('stroke-width', '2');
            svg.appendChild(beam);
          } else if (i > 0) {
            const stubX = stemX - stubLength;
            const beam = document.createElementNS(SVG_NS, 'line');
            beam.setAttribute('x1', stemX.toString());
            beam.setAttribute('y1', beamY.toString());
            beam.setAttribute('x2', stubX.toString());
            beam.setAttribute('y2', beamY.toString());
            beam.setAttribute('stroke', '#000');
            beam.setAttribute('stroke-width', '2');
            svg.appendChild(beam);
          }
          continue;
        }
        const beamY = baseStemBottom - (level - 1) * beamGap;
        const stemX = n.stemX!;
        if (leftHasLevel && !rightHasLevel && i > 0) {
          const stubX = stemX - stubLength;
          const beam = document.createElementNS(SVG_NS, 'line');
          beam.setAttribute('x1', stemX.toString());
          beam.setAttribute('y1', beamY.toString());
          beam.setAttribute('x2', stubX.toString());
          beam.setAttribute('y2', beamY.toString());
          beam.setAttribute('stroke', '#000');
          beam.setAttribute('stroke-width', '2');
          svg.appendChild(beam);
        }
        if (!leftHasLevel && rightHasLevel && i < beamedNotes.length - 1) {
          const stubX = stemX + stubLength;
          const beam = document.createElementNS(SVG_NS, 'line');
          beam.setAttribute('x1', stemX.toString());
          beam.setAttribute('y1', beamY.toString());
          beam.setAttribute('x2', stubX.toString());
          beam.setAttribute('y2', beamY.toString());
          beam.setAttribute('stroke', '#000');
          beam.setAttribute('stroke-width', '2');
          svg.appendChild(beam);
        }
      }
    }

    return notes.length ? notes[0].centerX : null;
  }

  private drawSlash(svg: SVGElement, x: number, y: number): void {
    const slashLength = 10;
    const slash = document.createElementNS(SVG_NS, 'line');
    slash.setAttribute('x1', (x + slashLength/2).toString());
    slash.setAttribute('y1', (y - slashLength/2).toString());
    slash.setAttribute('x2', (x - slashLength/2).toString());
    slash.setAttribute('y2', (y + slashLength/2).toString());
    slash.setAttribute('stroke', '#000');
    slash.setAttribute('stroke-width', '3');
    svg.appendChild(slash);
  }

  drawStem(svg: SVGElement, x: number, y: number, height: number): {x:number,topY:number,bottomY:number} {
    const slashLength = 10;
    const stemStartX = x - slashLength/2 + 2;
    const stemStartY = y + slashLength/2;
    const stem = document.createElementNS(SVG_NS, 'line');
    stem.setAttribute('x1', stemStartX.toString());
    stem.setAttribute('y1', stemStartY.toString());
    stem.setAttribute('x2', stemStartX.toString());
    stem.setAttribute('y2', (stemStartY + height).toString());
    stem.setAttribute('stroke', '#000');
    stem.setAttribute('stroke-width', '2');
    svg.appendChild(stem);
    return { x: stemStartX, topY: stemStartY, bottomY: stemStartY + height };
  }

  drawFlag(svg: SVGElement, x: number, staffLineY: number, count: number) {
    const slashLength = 10;
    const stemStartX = x - slashLength/2 + 2;
    const stemBottomY = staffLineY + slashLength/2 + 25;
    for (let i = 0; i < count; i++) {
      const flag = document.createElementNS(SVG_NS, 'path');
      const flagY = stemBottomY - i * 10;
      flag.setAttribute('d', `M ${stemStartX} ${flagY} Q ${stemStartX - 10} ${flagY - 5} ${stemStartX - 8} ${flagY - 12}`);
      flag.setAttribute('stroke', '#000');
      flag.setAttribute('stroke-width', '2');
      flag.setAttribute('fill', 'none');
      svg.appendChild(flag);
    }
  }

  createText(text: string, x: number, y: number, size: string, weight: string = 'normal'): SVGTextElement {
    const textEl = document.createElementNS(SVG_NS, 'text');
    textEl.setAttribute('x', x.toString());
    textEl.setAttribute('y', y.toString());
    textEl.setAttribute('font-family', 'Arial, sans-serif');
    textEl.setAttribute('font-size', size);
    textEl.setAttribute('font-weight', weight);
    textEl.setAttribute('fill', '#000');
    textEl.textContent = text;
    return textEl;
  }
}